<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Shader学习笔记-HLSL | Dand</title>
<meta name=keywords content="Shader,图形学,Unity"><meta name=description content="前言
上一篇介绍了ShaderLab的结构，这一篇继续介绍Shader的主要逻辑部分。
Unity的旧版本用的是CG语言，现在逐步淘汰了，主要用微软的HLSL，并加了一些Unity自己的语法。
预处理
include
include and include_with_pragmas directives in HLSL - Unity 手册
在 HLSL 中，#include 指令是一种预处理器指令。它们指示编译器将一个 HLSL 文件的内容包含在另一个 HLSL 文件中。它们包含的文件称为包含文件。
#include_with_pragmas 指令的工作方式与常规 #include 指令相同，但它也允许您在包含文件中使用 #pragma 指令。这意味着 #include_with_pragmas 指令允许您在多个文件之间共享 #pragma 指令。
在 HLSL 中向着色器编译器提供信息
Provide information to the shader compiler in HLSL - Unity 手册
#pragma target 3.0
#pragma exclude_renderers vulkan
#pragma vertex vert
#pragma fragment frag

// The rest of your HLSL code goes here
指定着色器阶段

  
      
          语句
          功能
      
  
  
      
          #pragma vertex <name>
          Compile the function with the given name as the vertex shader. Replace  with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为顶点着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。
      
      
          #pragma fragment <name>
          Compile the function with the given name as the fragment shader. Replace  with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为片段着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。
      
      
          #pragma geometry <name>
          Compile the function with the given name as the geometry shader. Replace  with the function name. This option automatically turns on #pragma require geometry; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为几何着色器。 替换为函数名称。此选项会自动打开 #pragma 需要几何图形;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。Note: Metal does not support geometry shaders.注意：Metal 不支持几何体着色器。
      
      
          #pragma hull <name>
          Compile the function with the given name as the DirectX 11 hull shader. Replace  with the function name. This automatically adds #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 hull 着色器。 替换为函数名称。这会自动添加 #pragma 需要曲面细分;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。
      
      
          #pragma domain <name>
          Compile the function with the given name as the DirectX 11 domain shader. Replace  with the function name. This option automatically turns on #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 域着色器。 替换为函数名称。此选项会自动打开 #pragma 需要镶嵌;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。
      
  

着色器变体和关键字"><meta name=author content="Dand"><link rel=canonical href=https://dandkong.github.io/posts/shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-hlsl/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://dandkong.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dandkong.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dandkong.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dandkong.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dandkong.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://dandkong.github.io/posts/shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-hlsl/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dandkong.github.io/posts/shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-hlsl/"><meta property="og:site_name" content="Dand"><meta property="og:title" content="Shader学习笔记-HLSL"><meta property="og:description" content="前言 上一篇介绍了ShaderLab的结构，这一篇继续介绍Shader的主要逻辑部分。
Unity的旧版本用的是CG语言，现在逐步淘汰了，主要用微软的HLSL，并加了一些Unity自己的语法。
预处理 include include and include_with_pragmas directives in HLSL - Unity 手册
在 HLSL 中，#include 指令是一种预处理器指令。它们指示编译器将一个 HLSL 文件的内容包含在另一个 HLSL 文件中。它们包含的文件称为包含文件。
#include_with_pragmas 指令的工作方式与常规 #include 指令相同，但它也允许您在包含文件中使用 #pragma 指令。这意味着 #include_with_pragmas 指令允许您在多个文件之间共享 #pragma 指令。
在 HLSL 中向着色器编译器提供信息 Provide information to the shader compiler in HLSL - Unity 手册
#pragma target 3.0 #pragma exclude_renderers vulkan #pragma vertex vert #pragma fragment frag // The rest of your HLSL code goes here 指定着色器阶段
语句 功能 #pragma vertex <name> Compile the function with the given name as the vertex shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为顶点着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。 #pragma fragment <name> Compile the function with the given name as the fragment shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为片段着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。 #pragma geometry <name> Compile the function with the given name as the geometry shader. Replace with the function name. This option automatically turns on #pragma require geometry; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为几何着色器。 替换为函数名称。此选项会自动打开 #pragma 需要几何图形;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。Note: Metal does not support geometry shaders.注意：Metal 不支持几何体着色器。 #pragma hull <name> Compile the function with the given name as the DirectX 11 hull shader. Replace with the function name. This automatically adds #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 hull 着色器。 替换为函数名称。这会自动添加 #pragma 需要曲面细分;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。 #pragma domain <name> Compile the function with the given name as the DirectX 11 domain shader. Replace with the function name. This option automatically turns on #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 域着色器。 替换为函数名称。此选项会自动打开 #pragma 需要镶嵌;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。 着色器变体和关键字"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-01T23:03:27+08:00"><meta property="article:modified_time" content="2024-09-01T23:03:27+08:00"><meta property="article:tag" content="Shader"><meta property="article:tag" content="图形学"><meta property="article:tag" content="Unity"><meta property="og:image" content="https://dandkong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dandkong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Shader学习笔记-HLSL"><meta name=twitter:description content="前言
上一篇介绍了ShaderLab的结构，这一篇继续介绍Shader的主要逻辑部分。
Unity的旧版本用的是CG语言，现在逐步淘汰了，主要用微软的HLSL，并加了一些Unity自己的语法。
预处理
include
include and include_with_pragmas directives in HLSL - Unity 手册
在 HLSL 中，#include 指令是一种预处理器指令。它们指示编译器将一个 HLSL 文件的内容包含在另一个 HLSL 文件中。它们包含的文件称为包含文件。
#include_with_pragmas 指令的工作方式与常规 #include 指令相同，但它也允许您在包含文件中使用 #pragma 指令。这意味着 #include_with_pragmas 指令允许您在多个文件之间共享 #pragma 指令。
在 HLSL 中向着色器编译器提供信息
Provide information to the shader compiler in HLSL - Unity 手册
#pragma target 3.0
#pragma exclude_renderers vulkan
#pragma vertex vert
#pragma fragment frag

// The rest of your HLSL code goes here
指定着色器阶段

  
      
          语句
          功能
      
  
  
      
          #pragma vertex <name>
          Compile the function with the given name as the vertex shader. Replace  with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为顶点着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。
      
      
          #pragma fragment <name>
          Compile the function with the given name as the fragment shader. Replace  with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为片段着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。
      
      
          #pragma geometry <name>
          Compile the function with the given name as the geometry shader. Replace  with the function name. This option automatically turns on #pragma require geometry; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为几何着色器。 替换为函数名称。此选项会自动打开 #pragma 需要几何图形;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。Note: Metal does not support geometry shaders.注意：Metal 不支持几何体着色器。
      
      
          #pragma hull <name>
          Compile the function with the given name as the DirectX 11 hull shader. Replace  with the function name. This automatically adds #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 hull 着色器。 替换为函数名称。这会自动添加 #pragma 需要曲面细分;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。
      
      
          #pragma domain <name>
          Compile the function with the given name as the DirectX 11 domain shader. Replace  with the function name. This option automatically turns on #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 域着色器。 替换为函数名称。此选项会自动打开 #pragma 需要镶嵌;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。
      
  

着色器变体和关键字"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dandkong.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Shader学习笔记-HLSL","item":"https://dandkong.github.io/posts/shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-hlsl/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Shader学习笔记-HLSL","name":"Shader学习笔记-HLSL","description":"前言 上一篇介绍了ShaderLab的结构，这一篇继续介绍Shader的主要逻辑部分。\nUnity的旧版本用的是CG语言，现在逐步淘汰了，主要用微软的HLSL，并加了一些Unity自己的语法。\n预处理 include include and include_with_pragmas directives in HLSL - Unity 手册\n在 HLSL 中，#include 指令是一种预处理器指令。它们指示编译器将一个 HLSL 文件的内容包含在另一个 HLSL 文件中。它们包含的文件称为包含文件。\n#include_with_pragmas 指令的工作方式与常规 #include 指令相同，但它也允许您在包含文件中使用 #pragma 指令。这意味着 #include_with_pragmas 指令允许您在多个文件之间共享 #pragma 指令。\n在 HLSL 中向着色器编译器提供信息 Provide information to the shader compiler in HLSL - Unity 手册\n#pragma target 3.0 #pragma exclude_renderers vulkan #pragma vertex vert #pragma fragment frag // The rest of your HLSL code goes here 指定着色器阶段\n语句 功能 #pragma vertex \u0026lt;name\u0026gt; Compile the function with the given name as the vertex shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为顶点着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。 #pragma fragment \u0026lt;name\u0026gt; Compile the function with the given name as the fragment shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为片段着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。 #pragma geometry \u0026lt;name\u0026gt; Compile the function with the given name as the geometry shader. Replace with the function name. This option automatically turns on #pragma require geometry; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为几何着色器。 替换为函数名称。此选项会自动打开 #pragma 需要几何图形;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。Note: Metal does not support geometry shaders.注意：Metal 不支持几何体着色器。 #pragma hull \u0026lt;name\u0026gt; Compile the function with the given name as the DirectX 11 hull shader. Replace with the function name. This automatically adds #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 hull 着色器。 替换为函数名称。这会自动添加 #pragma 需要曲面细分;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。 #pragma domain \u0026lt;name\u0026gt; Compile the function with the given name as the DirectX 11 domain shader. Replace with the function name. This option automatically turns on #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 域着色器。 替换为函数名称。此选项会自动打开 #pragma 需要镶嵌;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。 着色器变体和关键字\n","keywords":["Shader","图形学","Unity"],"articleBody":"前言 上一篇介绍了ShaderLab的结构，这一篇继续介绍Shader的主要逻辑部分。\nUnity的旧版本用的是CG语言，现在逐步淘汰了，主要用微软的HLSL，并加了一些Unity自己的语法。\n预处理 include include and include_with_pragmas directives in HLSL - Unity 手册\n在 HLSL 中，#include 指令是一种预处理器指令。它们指示编译器将一个 HLSL 文件的内容包含在另一个 HLSL 文件中。它们包含的文件称为包含文件。\n#include_with_pragmas 指令的工作方式与常规 #include 指令相同，但它也允许您在包含文件中使用 #pragma 指令。这意味着 #include_with_pragmas 指令允许您在多个文件之间共享 #pragma 指令。\n在 HLSL 中向着色器编译器提供信息 Provide information to the shader compiler in HLSL - Unity 手册\n#pragma target 3.0 #pragma exclude_renderers vulkan #pragma vertex vert #pragma fragment frag // The rest of your HLSL code goes here 指定着色器阶段\n语句 功能 #pragma vertex Compile the function with the given name as the vertex shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为顶点着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。 #pragma fragment Compile the function with the given name as the fragment shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为片段着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。 #pragma geometry Compile the function with the given name as the geometry shader. Replace with the function name. This option automatically turns on #pragma require geometry; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为几何着色器。 替换为函数名称。此选项会自动打开 #pragma 需要几何图形;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。Note: Metal does not support geometry shaders.注意：Metal 不支持几何体着色器。 #pragma hull Compile the function with the given name as the DirectX 11 hull shader. Replace with the function name. This automatically adds #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 hull 着色器。 替换为函数名称。这会自动添加 #pragma 需要曲面细分;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。 #pragma domain Compile the function with the given name as the DirectX 11 domain shader. Replace with the function name. This option automatically turns on #pragma require tessellation; for more information, see Targeting shader models and GPU features in HLSL.将具有给定名称的函数编译为 DirectX 11 域着色器。 替换为函数名称。此选项会自动打开 #pragma 需要镶嵌;有关详细信息，请参阅在 HLSL 中面向着色器模型和 GPU 功能。 着色器变体和关键字\nDirective 命令 描述 #pragma multi_compile Declares a collection of keywords. The compiler includes all of the keywords in the build.声明关键字的集合。编译器在构建中包含所有关键字。You can use suffixes such as _local to set additional options.您可以使用后缀（如 _local）来设置其他选项。For more information and a list of supported suffixes, see Declaring and using shader keywords in HLSL.有关详细信息和支持的后缀列表，请参阅在 HLSL 中声明和使用着色器关键字。 #pragma shader_feature Declares a collection of keywords. The compiler excludes unused keywords from the build.声明关键字的集合。编译器会从构建中排除未使用的关键字。You can use suffixes such as _local to set additional options.您可以使用后缀（如 _local）来设置其他选项。For more information and a list of supported suffixes, see Declaring and using shader keywords in HLSL.有关详细信息和支持的后缀列表，请参阅在 HLSL 中声明和使用着色器关键字。 #pragma hardware_tier_variants Built-in Render Pipeline only: Add keywords for graphics tiers when compiling for a given graphics API. For more information, see Graphics tiers.仅限内置渲染管线：在为给定图形 API 编译时为图形层添加关键字。有关详细信息，请参阅图形层。 #pragma skip_variants Strip specified keywords.去除指定的关键字。 GPU 要求和着色器模型支持\n语句 功能 #pragma target The minimum shader model that this shader program is compatible with. Replace with a valid value. For a list of valid values, see Shader compilation: Targeting shader models and GPU features in HLSL.此着色器程序兼容的最小着色器模型。 替换为有效值。有关有效值的列表，请参阅着色器编译：面向 HLSL 中的着色器模型和 GPU 功能。 #pragma require The minimum GPU features that this shader is compatible with. Replace with a valid value, or multiple valid values separated by a space. For a list of valid values, see Shader compilation: Targeting shader models and GPU features in HLSL.此着色器兼容的最低 GPU 功能。 替换为一个有效值，或用空格分隔的多个有效值。有关有效值的列表，请参阅着色器编译：面向 HLSL 中的着色器模型和 GPU 功能。 其他 Shader模型和特性\nTargeting shader models and GPU features in HLSL - Unity 手册\nTargeting graphics APIs and platforms in HLSL - Unity 手册\n变体\nDeclaring and using shader keywords in HLSL - Unity 手册\nShader变体 着色器变体和关键字 - Unity 手册\nShader变体有两种声明方法。\nshader_feature 和 multi_compile 都是 Unity Shader 中用于控制着色器变体（Shader Variants）生成的关键字，但它们有一些区别：\nshader_feature 仅在使用到相关特性时才会编译包含该特性的变体。 可以减少最终生成的变体数量，因为只有实际需要的变体才会被编译。 适用于那些在运行时根据某些条件才启用的特性，例如某些高级图形效果可能只在特定设备或场景中使用。 multi_compile 会编译所有指定的变体，无论是否实际使用到。 会导致生成更多的变体，可能会增加编译时间和占用更多的内存。 适用于那些需要在不同情况下切换使用的多个变体，例如不同的光照条件或材质属性。 dynamic_branch 无变体 增加GPU压力 在代码端，需要配合API动态修改本地的关键字或者全局的关键字，参考以下\nUsing shader keywords with C# scripts - Unity 手册\n总结 Shader中的HLSL部分总结就这么多，需要更详细的说明可以参考Unity官方教程。\n","wordCount":"577","inLanguage":"zh","image":"https://dandkong.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-01T23:03:27+08:00","dateModified":"2024-09-01T23:03:27+08:00","author":{"@type":"Person","name":"Dand"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dandkong.github.io/posts/shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-hlsl/"},"publisher":{"@type":"Organization","name":"Dand","logo":{"@type":"ImageObject","url":"https://dandkong.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dandkong.github.io/ accesskey=h title="Dand (Alt + H)"><img src=https://dandkong.github.io/images/avatar.png alt aria-label=logo height=35>Dand</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dandkong.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://dandkong.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://dandkong.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dandkong.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://dandkong.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Shader学习笔记-HLSL</h1><div class=post-meta><span title='2024-09-01 23:03:27 +0800 CST'>2024-9-1</span>&nbsp;·&nbsp;Dand</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e9%a2%84%e5%a4%84%e7%90%86 aria-label=预处理>预处理</a><ul><li><a href=#include aria-label=include>include</a></li><li><a href=#%e5%9c%a8-hlsl-%e4%b8%ad%e5%90%91%e7%9d%80%e8%89%b2%e5%99%a8%e7%bc%96%e8%af%91%e5%99%a8%e6%8f%90%e4%be%9b%e4%bf%a1%e6%81%af aria-label="在 HLSL 中向着色器编译器提供信息">在 HLSL 中向着色器编译器提供信息</a></li><li><a href=#%e5%85%b6%e4%bb%96 aria-label=其他>其他</a></li></ul></li><li><a href=#shader%e5%8f%98%e4%bd%93 aria-label=Shader变体>Shader变体</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><h2 id=前言><strong>前言</strong><a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>上一篇介绍了ShaderLab的结构，这一篇继续介绍Shader的主要逻辑部分。</p><p>Unity的旧版本用的是CG语言，现在逐步淘汰了，主要用微软的HLSL，并加了一些Unity自己的语法。</p><h2 id=预处理>预处理<a hidden class=anchor aria-hidden=true href=#预处理>#</a></h2><h3 id=include><strong>include</strong><a hidden class=anchor aria-hidden=true href=#include>#</a></h3><p><a href=https://docs.unity3d.com/cn/2023.2/Manual/shader-include-directives.html>include and include_with_pragmas directives in HLSL - Unity 手册</a></p><p>在 HLSL 中，<code>#include</code> 指令是一种<a href=https://docs.unity3d.com/cn/2023.2/Manual/shader-preprocessor-directives.html>预处理器指令</a>。它们指示编译器将一个 HLSL 文件的内容包含在另一个 HLSL 文件中。它们包含的文件称为<strong>包含文件</strong>。</p><p><code>#include_with_pragmas</code> 指令的工作方式与常规 <code>#include</code> 指令相同，但它也允许您在包含文件中使用 <code>#pragma</code> 指令。这意味着 <code>#include_with_pragmas</code> 指令允许您在多个文件之间共享 <code>#pragma</code> 指令。</p><h3 id=在-hlsl-中向着色器编译器提供信息><strong>在 HLSL 中向着色器编译器提供信息</strong><a hidden class=anchor aria-hidden=true href=#在-hlsl-中向着色器编译器提供信息>#</a></h3><p><a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-PragmaDirectives.html>Provide information to the shader compiler in HLSL - Unity 手册</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-glsl data-lang=glsl><span class=line><span class=cl><span class=cp>#pragma target 3.0</span>
</span></span><span class=line><span class=cl><span class=cp>#pragma exclude_renderers vulkan</span>
</span></span><span class=line><span class=cl><span class=cp>#pragma vertex vert</span>
</span></span><span class=line><span class=cl><span class=cp>#pragma fragment frag</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The rest of your HLSL code goes here</span>
</span></span></code></pre></div><p>指定着色器阶段</p><table><thead><tr><th><strong>语句</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>#pragma vertex &lt;name></code></td><td>Compile the function with the given name as the vertex shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为顶点着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。</td></tr><tr><td><code>#pragma fragment &lt;name></code></td><td>Compile the function with the given name as the fragment shader. Replace with the function name. This directive is required in regular graphics shaders.将具有给定名称的函数编译为片段着色器。 替换为函数名称。此指令在常规图形着色器中是必需的。</td></tr><tr><td><code>#pragma geometry &lt;name></code></td><td>Compile the function with the given name as the geometry shader. Replace with the function name. This option automatically turns on <code>#pragma require geometry</code>; for more information, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>Targeting shader models and GPU features in HLSL</a>.将具有给定名称的函数编译为几何着色器。 替换为函数名称。此选项会自动打开 <code>#pragma 需要几何图形</code>;有关详细信息，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>在 HLSL 中面向着色器模型和 GPU 功能</a>。<strong>Note</strong>: Metal does not support geometry shaders.<strong>注意</strong>：Metal 不支持几何体着色器。</td></tr><tr><td><code>#pragma hull &lt;name></code></td><td>Compile the function with the given name as the DirectX 11 hull shader. Replace with the function name. This automatically adds <code>#pragma require tessellation</code>; for more information, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>Targeting shader models and GPU features in HLSL</a>.将具有给定名称的函数编译为 DirectX 11 hull 着色器。 替换为函数名称。这会自动添加 <code>#pragma 需要曲面细分</code>;有关详细信息，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>在 HLSL 中面向着色器模型和 GPU 功能</a>。</td></tr><tr><td><code>#pragma domain &lt;name></code></td><td>Compile the function with the given name as the DirectX 11 domain shader. Replace with the function name. This option automatically turns on <code>#pragma require tessellation</code>; for more information, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>Targeting shader models and GPU features in HLSL</a>.将具有给定名称的函数编译为 DirectX 11 域着色器。 替换为函数名称。此选项会自动打开 <code>#pragma 需要镶嵌;</code>有关详细信息，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>在 HLSL 中面向着色器模型和 GPU 功能</a>。</td></tr></tbody></table><p>着色器变体和关键字</p><table><thead><tr><th><strong>Directive 命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>#pragma multi_compile &lt;keywords></code></td><td>Declares a collection of keywords. The compiler includes all of the keywords in the build.声明关键字的集合。编译器在构建中包含所有关键字。You can use suffixes such as <code>_local</code> to set additional options.您可以使用后缀（如 <code>_local</code>）来设置其他选项。For more information and a list of supported suffixes, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-MultipleProgramVariants.html>Declaring and using shader keywords in HLSL</a>.有关详细信息和支持的后缀列表，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-MultipleProgramVariants.html>在 HLSL 中声明和使用着色器关键字</a>。</td></tr><tr><td><code>#pragma shader_feature &lt;keywords></code></td><td>Declares a collection of keywords. The compiler excludes unused keywords from the build.声明关键字的集合。编译器会从构建中排除未使用的关键字。You can use suffixes such as <code>_local</code> to set additional options.您可以使用后缀（如 <code>_local</code>）来设置其他选项。For more information and a list of supported suffixes, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-MultipleProgramVariants.html>Declaring and using shader keywords in HLSL</a>.有关详细信息和支持的后缀列表，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-MultipleProgramVariants.html>在 HLSL 中声明和使用着色器关键字</a>。</td></tr><tr><td><code>#pragma hardware_tier_variants &lt;values></code></td><td>Built-in Render Pipeline only: Add keywords for <strong>graphics tiers</strong> when compiling for a given graphics API. For more information, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/graphics-tiers.html>Graphics tiers</a>.仅限内置渲染管线：在为给定图形 API 编译时为<strong>图形层</strong>添加关键字。有关详细信息，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/graphics-tiers.html>图形层</a>。</td></tr><tr><td><code>#pragma skip_variants &lt;list of keywords></code></td><td>Strip specified keywords.去除指定的关键字。</td></tr></tbody></table><p>GPU 要求和着色器模型支持</p><table><thead><tr><th><strong>语句</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>#pragma target &lt;value></code></td><td>The minimum shader model that this shader program is compatible with. Replace with a valid value. For a list of valid values, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>Shader compilation: Targeting shader models and GPU features in HLSL</a>.此着色器程序兼容的最小着色器模型。 替换为有效值。有关有效值的列表，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>着色器编译：面向 HLSL 中的着色器模型和 GPU 功能</a>。</td></tr><tr><td><code>#pragma require &lt;value></code></td><td>The minimum GPU features that this shader is compatible with. Replace with a valid value, or multiple valid values separated by a space. For a list of valid values, see <a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>Shader compilation: Targeting shader models and GPU features in HLSL</a>.此着色器兼容的最低 GPU 功能。 替换为一个有效值，或用空格分隔的多个有效值。有关有效值的列表，请参阅<a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>着色器编译：面向 HLSL 中的着色器模型和 GPU 功能</a>。</td></tr></tbody></table><h3 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h3><p>Shader模型和特性</p><p><a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompileTargets.html>Targeting shader models and GPU features in HLSL - Unity 手册</a></p><p><a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-ShaderCompilationAPIs.html>Targeting graphics APIs and platforms in HLSL - Unity 手册</a></p><p>变体</p><p><a href=https://docs.unity3d.com/cn/2023.2/Manual/SL-MultipleProgramVariants.html>Declaring and using shader keywords in HLSL - Unity 手册</a></p><h2 id=shader变体>Shader变体<a hidden class=anchor aria-hidden=true href=#shader变体>#</a></h2><p><a href=https://docs.unity3d.com/cn/2019.4/Manual/SL-MultipleProgramVariants.html>着色器变体和关键字 - Unity 手册</a></p><p>Shader变体有两种声明方法。</p><p><code>shader_feature</code> 和 <code>multi_compile</code> 都是 Unity Shader 中用于控制着色器变体（Shader Variants）生成的关键字，但它们有一些区别：</p><ol><li><pre tabindex=0><code>shader_feature
</code></pre><ul><li>仅在使用到相关特性时才会编译包含该特性的变体。</li><li>可以减少最终生成的变体数量，因为只有实际需要的变体才会被编译。</li><li>适用于那些在运行时根据某些条件才启用的特性，例如某些高级图形效果可能只在特定设备或场景中使用。</li></ul></li><li><pre tabindex=0><code>multi_compile
</code></pre><ul><li>会编译所有指定的变体，无论是否实际使用到。</li><li>会导致生成更多的变体，可能会增加编译时间和占用更多的内存。</li><li>适用于那些需要在不同情况下切换使用的多个变体，例如不同的光照条件或材质属性。</li></ul></li><li><pre tabindex=0><code>dynamic_branch
</code></pre><ul><li>无变体</li><li>增加GPU压力</li></ul></li></ol><p>在代码端，需要配合API动态修改本地的关键字或者全局的关键字，参考以下</p><p><a href=https://docs.unity3d.com/cn/2023.2/Manual/shader-keywords-scripts.html>Using shader keywords with C# scripts - Unity 手册</a></p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>Shader中的HLSL部分总结就这么多，需要更详细的说明可以参考Unity官方教程。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dandkong.github.io/tags/shader/>Shader</a></li><li><a href=https://dandkong.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/>图形学</a></li><li><a href=https://dandkong.github.io/tags/unity/>Unity</a></li></ul><nav class=paginav><a class=prev href=https://dandkong.github.io/posts/laya%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/><span class=title>« 上一页</span><br><span>Laya性能分析工具</span>
</a><a class=next href=https://dandkong.github.io/posts/shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-shaderlab%E7%BB%93%E6%9E%84/><span class=title>下一页 »</span><br><span>Shader学习笔记-ShaderLab结构</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dandkong.github.io/>Dand</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>