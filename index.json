[{"categories":["Unity"],"content":"一、概述 游戏中角色移动分为了主动和被动，主动主要由玩家通过摇杆或者键盘进行操作，被动移动主要应用于自动寻路，通过寻路点行动。 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:1:0","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"二、主动移动 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:0","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"移动组件 移动组件主要用到Unity的移动组件Character Controller，主要属性如下 Height角色的高度，通常和现实中的人物一样设置为2米左右。 Radius角色的半径，用于控制人物的胖瘦。 Center设置角色中心点的位置。 Slope Limit限制角色能爬的最大坡度。通常设置为90度以下，这样角色就不会走到墙上。 Step Offset移动步长。通常2米左右的人移动步长设置在0.1到0.4米. Skin Width皮肤厚度。如果这个值太小角色容易被卡住，太大角色容易抖动。通常将这个数据设为0.01到角色半径的10%之间。 Min Move Distance最小移动距离。官方推荐把这个值设为0。 isGrounded可以获取角色当前是否在地面。 velocity可以获取角色当前的速度向量。 移动方法主要用到Move，Move方法需要自己实现重力的效果，看具体项目需求 //用摇杆控制方向，当按下空格键时跳起。 using UnityEngine; using System.Collections; public class ExampleClass : MonoBehaviour { public float speed = 6.0F; public float jumpSpeed = 8.0F; public float gravity = 20.0F; private Vector3 moveDirection = Vector3.zero; void Update() { CharacterController controller = GetComponent\u003cCharacterController\u003e(); if (controller.isGrounded) { moveDirection = GetTargetPos(nowPos) - nowPos; // 跳跃 if (Input.GetButton(\"Jump\")) moveDirection.y = jumpSpeed; } //Move方法需要自己写重力效果 moveDirection.y -= gravity * Time.deltaTime; //移动控制器 controller.Move(moveDirection * Time.deltaTime); } } ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:1","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"每帧目标点的计算 速度模拟模拟现实中人物移动的特征，起步时加速，计算代码如下 Vector3 GetTargetPos(Vector3 pos) { //计算实时速度，addSpeed为加速度 curMoveSpeed = Mathf.MoveTowards(curMoveSpeed, MaxSpeed, addSpeed * deltaTime); //计算终点，curMoveDir由输入决定 pos += curMoveSpeed * curMoveDir * deltaTime } ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:2","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"动画状态机 移动时需要动作配合，动作主要由Animator组件实现，通过设置不同的参数，实现状态之间的转换，还可以细化，加上准备跳跃，跳跃落地等等。 通过SetTrigger进行不同运动状态的切换，通过SetBool进行移动和静止状态间的切换。 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:3","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"管理组件 主动移动的管理组件主要功能如下 接收输入方向 状态机维护当前角色状态（普通，跳跃），设置对应动画状态 计算下一帧移动方向 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:4","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"二、自动寻路 自动寻路主要是计算出起始点到目标点的一连串的中间点，每次走一小段直线，从而完成寻路的过程，逻辑比较简单， 如果使用Unity自带的Nav Mesh Agent 可以使用参考https://bbs.huaweicloud.com/blogs/303788。 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:3:0","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"计算寻路点 计算寻路点主要用到Unity的NavMesh类中的CalculatePath方法，得到寻路点以后只要逐个进行寻路即可。 public static bool CalculatePath(Vector3 sourcePosition, Vector3 targetPosition, int areaMask, AI.NavMeshPath path); ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:3:1","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"逐点寻路 计算出寻路点以后，在Update中执行 private void UpdateMove(float deltaTime) { float time = Vector3.Distance(_nowPos, _destList[index])/speed; If(deltaTime \u003e time) { //如果到最后一个，结束 //没有的话，index++ //多出的时间留给下个寻路点 UpdateMove(deltaTime - time); } else { //插值 _nowPos = Vector3.Lerp(_nowPos, _destList[index], deltaTime / time); } } ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:3:2","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["游戏框架"],"content":"概述 一般副本中都会包括各种各样的行为和判断逻辑，下面举一个简单的副本例子，进入副本后，如果组队人数到达三个，则刷出怪物，播放特效，播放对话，与怪物战斗后，弹出结算UI，再播个动画。 如果由策划出完案子后程序负责直接实现的话，每个副本都是定制化的，写起来非常难受，而且维护极不方便，一旦需求改动就要重新写代码 所以需要设计一套副本系统可以灵活配置副本功能，想法是把副本里的每个行为，判断都作为一个节点，类型行为树的概念，从开始节点一直执行到结束节点，这个副本进程就结束了，进入下个副本进程。 编辑器使用连线的方式操作，每个节点的前后置关系，导出lua配置供程序使用，服务端控制执行流程，客户端只需要执行节点逻辑。 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:1:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"例子 节点可以分为执行节点和判断节点，执行节点执行一个行为，流程推进，判断节点在符合条件的时候，推进流程，否则暂停。 端口定义了每个节点间的关系，也就是图中的连线，控制流程走向，比如刷怪战斗节点，输入端口连接“判断组队人数”，有两个输出端口，分别是胜利和失败，连接对应的节点。 把副本流程解构成一个个节点以后，只需要维护节点的行为和端口逻辑即可，组合由策划完成，只有在添加新节点时程序才需要上场。 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:2:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"编辑器 编辑器可以用网上的开源例子xnode组织节点，也可自己实现。 导出的数据包括了节点的类型，参数，前后置节点等一切代码需要的信息。 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:3:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"副本流程 服务端推送当前节点信息 服务端执行/客户端执行 服务端/客户端完成节点，推进流程 直到到达结束节点 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:4:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"一、概述 一般MMO的游戏由场景和场景中的对象构成，在设计地图时，就会遇到几个问题。怎么有效直观地配置信息，对象都有什么功能，有什么功能是共有的。针对上面的问题，首先需要解决的是抽象出场景对象结构，在此基础上做编辑器，用图形化的界面展示，修改储存数据，供代码使用。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:1:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"二、场景对象结构 场景本事有数据，如场景资源，组队人数限制等等，这种信息改动不大，也比较直观，一般只要存在excel里面就好，需要的话可以做图形编辑器对excel进行读写和修改。 场景中的对象可以按需分成几类，常见的有npc，采集物，区域，点等等。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"NPC NPC主要承载了显示模型的功能，读取NPC表。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:1","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"采集物 采集物和NPC差不多，只是对话交互改成了点击采集。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:2","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"区域 区域分成了圆形区域和多边形区域，划分区域可以实现进入和离开区域的逻辑，比如划分了游泳区，飞行区等，进入以后主角切换运动状态。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:3","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"点 点的功能比较广泛，主要用于定位，也可以添加触发组件以后实现圆形区域的功能。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:4","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"组件 组件是对象上的属性和功能，公用的组件有缩放，大小，显示隐藏条件等，特殊的组件有巡逻，交互按钮等，按需添加，从而赋予对象特性。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:5","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"三、场景编辑器 理清了场景对象的结构以后，就可以做编辑器把数据组织起来了，场景编辑器的实现细节不多说，尽量用起来符合直观操作即可，功能如下。 增删改场景信息 直观展示场景中的对象（位置、模型、范围等） 增删改场景中的对象 修改对象的组件属性 导出程序可用数据 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:3:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"四、数据载体 数据可以直接导出lua，也可以导出成json，xml等，只要方便维护，程序方便调用即可。 目前使用的是先储存到excel，再从excel导出到lua中，供程序调用。 使用excel作为中间载体的原因可能是比较直观，但感觉使用json或者Unity序列化的方法也是可行的。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:4:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"概述 游戏对象管理一般是通过总分结构，管理器为RoleMgr，对象为Role，Role的功能由各种功能组件实现，从而实现继承和解耦。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:1:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"RoleMgr 管理类管理游戏中所有的Role，负责Role的创建、查找、销毁，一般配合UID生成器，给每一个Role分配一个唯一ID作为唯一的标识。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:2:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"Role Role是游戏中的对象，可以是角色，特效，建筑等等游戏中的一切实体，由BaseRole派生。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:3:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"BaseRole 基类，定义Role的最基本信息，如GameObject，Transform信息，显示隐藏状态等等。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:4:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"派生 对BaseRole进行派生就是具体的游戏对象，如添加了控制器以后就是角色，再添加主动移动的控制器以后就是主角，通过绑定不同的组件实现Role的不同方向功能。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:5:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"Role的功能 Role的功能都由挂载的组件实现，常用的组件有 模型组件 被动移动组件 主动移动组件 显示隐藏组件（多条件） 范围触发组件（当玩家走进时会触发回调） 头顶文本组件 还有各种项目中需要实现的功能 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:6:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"Role的结构 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:7:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["Unity"],"content":"前言 UI是游戏中很重要的一部分，工作大多是繁复的，所以有一套功能强大，操作简单直观的UI解决方案是非常有必要的。 上半年一直在用FGUI，和之前用的UGUI相比下来，各有优缺点，对比分析记录一下。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:1:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"一、介绍 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:2:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"UGUI UGUI是Unity原生提供的UI方案，提供了基本的UI组件，如图片，文本，按钮，复选框，进度条等等，正是因为UGUI是面向普遍开发，所以没有封装很多高级的组件，比如虚拟列表。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:2:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"FGUI FairyGUI（下来简称FGUI）号称易上手，直观，零代码，有一个独立的编辑器，封装了很多高级的UI组件，用起来不需要自己造轮子。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:2:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"二、编辑器使用体验 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:3:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"UGUI 优点：稳定。 缺点：因为集成在Unity中，资源管理不太方便，需要项目定好规范，编写工具提交效率。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:3:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"FGUI 优点：有单独的编辑器，所有资源统一管理，美术策划也能很快上手使用。 缺点：不稳定，经常会莫名卡住，导出的时候经常报错。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:3:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"三、基础组件 基础组件上面因为FGUI实现很多的高级功能，所以使用起来体验要么一样，要么好点。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"文本 FGUI文本支持ubb语法，富文本支持图文混排，超链接等等，自动大小的文本。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"列表 FGUI实现了虚拟列表，树列表。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"字体 字体上FGUI提供了工具制作美术字，只要把资源拖进去专用的编辑器就能很快做出一个美术字体。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:3","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"动效系统 两者都有动效系统，UGUI上叫Animation，功能上差不多，都很强大。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:4","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"四、对齐系统 对齐系统这一块，FGUI是很大的亮点。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:5:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"UGUI UGUI的锚点系统以中心点为基准，对父节点对齐，提供了上下左右，拉伸对齐方式。 **优点：**简单直观UI默认的中心点在中心，符合人的正常思维。 缺点：不够灵活；同级UI之前的关联对齐要依赖其他布局组件；缺乏针对同级元素的对齐工具，不过可以自己拓展实现，可以参考我的另一篇文章。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:5:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"FGUI 优点：FGUI的对齐系统叫做关联系统，第一个优点是不局限与与父节点对齐，可以对任意两个元素进行对齐。第二个优点是在拓展了对齐的维度，可以以上下左右边缘为基准，可以以上下左右为基准拉伸，复杂一点，但是学会以后可以很方便实现一些效果，比如一张图片随着文字的变长而往右移动。 缺点：垂直布局和水平布局功能太单一；锚点在左上角各种反人类。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:5:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"五、FGUI特色功能 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"资源引用查找工具 可以轻易找到组件（图片）和其他组件的引用关系。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"支持多国语言 原生支持多国语言，可以导出xml维护即可。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"控制器系统 控制器系统一般用于控制显示一些UI元素的状态，可以配合动效和Tab使用，UGUI一般要通过代码控制或者自己实现一个类似的系统。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:3","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"多平台 FGUI可以一套UI，应用到不同的游戏引擎去，比如Unity和Unreal，对于后期可能更换引擎的项目，节省掉很多成本。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:4","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"插入3D物体 支持在UI层中插入任何3D物体，例如模型、粒子、骨骼动画等，UGUI中要通过修改特效和UI的渲染顺序实现，比较麻烦。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:5","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"六、拓展性 两者都有拓展性，FGUI的拓展性在于代码是开源的，可以在底层定制适合项目的功能，但是编辑器是不开源的，所以编辑器里面的东西改不了，虽然编辑器提供了脚本拓展支持，但能实现的东西不多。 UGUI的拓展性在于可以轻松地对编辑器进行拓展，也可以加上各种效果，一般也不会动到底层的如网格重构和渲染的代码，真想修改的话可能要和Unity进行合作然后项目搞一个魔改版的Unity。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:7:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"七、总结 总的来说两种UI解决方案都可以商用，不会有特别大的问题。 要是策划美术拼UI的话，可以选择FGUI，相反要是程序负责的话，两者都可以，但个人感觉Unity上的操作更加熟悉一点，程序员也可以在平时的UI流程中，吸收一些FGUI的思想，做些工具提高UI的开发效率。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:8:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"前言 上半年的大半年时间都在用FGUI，最近又用回了UGUI，发现FGUI的一些工具还是很高效的，比如对齐工具，想着说移植到UGUI里面去，上网搜了一圈还真有，原理并不复杂，就是进行一些数学计算出最终的位置。 不过也没有完全适合项目需求，针对原项目基础上添加了三个功能，下面介绍一下。 ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:1:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"一、撤销功能 原项目的工具在修改后，习惯性就按下Ctrl+Z，发现并不能撤销原来的操作，查询了Unity的API后，发现有个Undo的类，可以实现撤销功能，有很多方法，主要用到了RecordObject，代码如下 private static void SetTranPos(Transform tran, Vector3 pos) { Undo.RecordObject(tran, \"modify posstion\"); tran.position = pos; } ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:2:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"二、Selection.GameObjects不是按选择顺序的 API中的Selection.GameObjects用于获取当前选中的物件，数组的顺序和我选择的顺序无关，所以不能实现灵活的对齐，查询网上文章可以用Selection.Objects替代，里面的第一个元素就是Ctrl选中的第一个元素，以此类推，代码如下 //按选中顺序获取GameObjects private static GameObject[] GetOrderedSelctionObjs() { return Selection.objects.OfType\u003cGameObject\u003e().ToArray(); } ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:3:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"三、添加对父节点对齐 功能就是和标题一样，原项目是没有的，代码如下 //如果只选中一个，对父节点对齐 if (rects.Count == 1) { if (rects[0].parent != null \u0026\u0026 rects[0].parent.GetComponent\u003cRectTransform\u003e() != null) { rects.Insert(0, rects[0].parent.GetComponent\u003cRectTransform\u003e()); } } ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:4:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"四、代码 ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:5:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"UGUIAlign using System.Collections.Generic; using System.Linq; using UnityEditor; using UnityEngine; public enum AlignType { Top = 1, Left = 2, Right = 3, Bottom = 4, HorizontalCenter = 5, //水平居中 VerticalCenter = 6, //垂直居中 Horizontal = 7, //横向分布 Vertical = 8, //纵向分布 } public class UGUIAlign : Editor { [MenuItem(\"GameObject/UI/Align/Left 【左对齐】\")] static void AlignLeft() { Align(AlignType.Left); } [MenuItem(\"GameObject/UI/Align/HorizontalCenter 【水平居中】\")] static void AlignHorizontalCenter() { Align(AlignType.HorizontalCenter); } [MenuItem(\"GameObject/UI/Align/Right 【右对齐】\")] static void AlignRight() { Align(AlignType.Right); } [MenuItem(\"GameObject/UI/Align/Top 【顶端对齐】\")] static void AlignTop() { Align(AlignType.Top); } [MenuItem(\"GameObject/UI/Align/VerticalCenter 【垂直居中】\")] static void AlignVerticalCenter() { Align(AlignType.VerticalCenter); } [MenuItem(\"GameObject/UI/Align/Bottom 【底端对齐】\")] static void AlignBottom() { Align(AlignType.Bottom); } [MenuItem(\"GameObject/UI/Align/Horizontal 【横向分布】\")] static void AlignHorizontal() { Align(AlignType.Horizontal); } [MenuItem(\"GameObject/UI/Align/Vertical 【纵向分布】\")] static void AlignVertical() { Align(AlignType.Vertical); } public static void Align(AlignType type) { List\u003cRectTransform\u003e rects = new List\u003cRectTransform\u003e(); GameObject[] objects = GetOrderedSelctionObjs(); if (objects != null \u0026\u0026 objects.Length \u003e 0) { for (int i = 0; i \u003c objects.Length; i++) { RectTransform rect = objects[i].GetComponent\u003cRectTransform\u003e(); if (rect != null) rects.Add(rect); } } //如果只选中一个，对父节点对齐 if (rects.Count == 1) { if (rects[0].parent != null \u0026\u0026 rects[0].parent.GetComponent\u003cRectTransform\u003e() != null) { rects.Insert(0, rects[0].parent.GetComponent\u003cRectTransform\u003e()); } } if (rects.Count \u003e 1) { Align(type, rects); } } //按选中顺序获取GameObjects private static GameObject[] GetOrderedSelctionObjs() { return Selection.objects.OfType\u003cGameObject\u003e().ToArray(); } public static void Align(AlignType type, List\u003cRectTransform\u003e rects) { RectTransform tenplate = rects[0]; float w = tenplate.sizeDelta.x * tenplate.lossyScale.x; float h = tenplate.sizeDelta.y * tenplate.lossyScale.y; float x = tenplate.position.x - tenplate.pivot.x * w; float y = tenplate.position.y - tenplate.pivot.y * h; switch (type) { case AlignType.Top: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.lossyScale.y; Vector3 pos = trans.position; pos.y = y + h - th + trans.pivot.y * th; SetTranPos(trans, pos); } break; case AlignType.Left: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + tw * trans.pivot.x; SetTranPos(trans, pos); } break; case AlignType.Right: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + w - tw + tw * trans.pivot.x; SetTranPos(trans, pos); } break; case AlignType.Bottom: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.lossyScale.y; Vector3 pos = trans.position; pos.y = y + th * trans.pivot.y; SetTranPos(trans, pos); } break; case AlignType.HorizontalCenter: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + 0.5f * w - 0.5f * tw + tw * trans.pivot.x; SetTranPos(trans, pos); } break; case AlignType.VerticalCenter: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.lossyScale.y; Vector3 pos = trans.position; pos.y = y + 0.5f * h - 0.5f * th + th * trans.pivot.y; SetTranPos(trans, pos); } break; case AlignType.Horizontal: float minX = GetMinX(rects); float maxX = GetMaxX(rects); rects.Sort(SortListRectTransformByX); float distance = (maxX - minX) / (rects.Count - 1); for (int i = 1; i \u003c rects.Count - 1; i++) { RectTransform trans = r","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:5:1","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"五、代码下载 https://github.com/dandkong/UGUIAlign ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:6:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"六、参考 Unity编辑器拓展之十：UI对齐工具 ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:7:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity","学习笔记"],"content":"前言 这本书忘记从哪里下载了，和别的技术书籍不太一样，大多的内容都比较贴合项目开发，所以有一定的参考价值。 里面有几个章节觉得有收获的，主要是框架的设计，以及一些解决问题的思路，大致做了笔记或者摘录。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"一、基础内容交流 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码规范 可读代码：由于动态语言的类型灵活性，可以在变量前加上变量类型简称 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"正确使用断言与返回 注意什么时候可以为空，不要盲目返回 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"可拓展接口使用 多参数，下面演示了三种写法，最终应该在保留必要参数的情况下，可选参数做成table addModulePower(nModuleId, nPower); addModulePower(nModuleId,nPower,bSyncMsg,bSendEvent, bOnlyBoss) if( tOption \u0026\u0026 tOption.bSyncMsg){ //做这个参数该干的事情 } ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"调试的思维与逻辑 正向和逆向思维，逆向更快 不易复现的bug，埋下日志，下次使用 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"培养敏锐的异常反应 注意生命周期的创建与销毁 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:5","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码修改与重构 我们在项目中秉持一个原则，如果有个接口让你不舒服，比如说多传了几个参数，那么我们一定要提出来，那一定是接口的设计不够简单或者没有提供更简单的接口形式。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:6","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"优雅的使用外部代码 我们的一个原则就是要尽可能少去直接和引擎进行交互，而是更多的进行局部缓存，把战场拉回到更加通用的逻辑里面。 修改后的代码为： let levelSlider = Core.createBitmapByName(\"slider_png\"); let nSliderX = 0; if(XXX){ nSliderX += 6; } if(XXX){ nSliderX += 8; } if(XXX){ nSliderX -= 2; } levelSlider.x -= nSliderX; 选择简单的接口/参数以及尽量少的使用/调用底层接口就是我们所谓的正确的代码使用方式。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:7","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码审查 取出一个管理器对象。然后直接访问了它的成员函数，这是非常不应该行为。第一个是这个成员不应该是公有的，而应该是私有的，它的公有性质破坏了类的封装。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:8","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"从面试的角度看面试 基础能力，逻辑能力，硬核能力 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:9","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"如何应对代码错误 作为项目的主程，还需要统一思想。这个过程包括要求大家遵循统一的代码命名等，这也是规避错误的一个重要手段。越是相似的代码风格，代码的阅读速度就会越快。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:10","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"二、逻辑设计模式式讨论 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"分层设计 事件的派发遵循从下往上：比如M驱动V 依赖性越强的越靠下层 变化的放上层，底层可以互相依赖，逻辑层不允许相互依赖 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"主动和被动 被动模式，依赖事件，及时，性能消耗少，当被动模式不在能支持复杂逻辑时，可以考虑主动模式 主动模式，依赖轮询，有点像ESC的系统层监听实体层的感觉了。优点在于可以监听多种条件 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"阻塞和非阻塞 主要用于资源加载，阻塞速度快 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"统一与非统一 效率没有打到一定程度的影响时，推荐考虑统一性 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"三、框架设计初步 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"基类 存活状态，唯一ID ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"框架代码结构 子类关注的基类接口一定是个空的实现，意味着子类不需要考虑去调用父类同名的接口。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"框架设计 配置化编程：消除重复代码，如协议监听，按钮监听等等 自动化平衡处理：如果没有销毁，帮忙擦下屁股 机制有助于实现全局性的功能，尤其处理大规模需要重复代码的东西 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"框架拓展的思路 基础能力，封装类，继承到框架中 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:4","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"四、逻辑设计原理 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"缓存的设计 缓存存放的东西有限，不能所有的东西都放缓存。 缓存应该具备清理功能。 缓存系统应该具备一定的匹配能力。 缓存具备最小保留数量以及预先创建的能力 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"分线漫谈 分线，是将玩家划分到不同的频道中，不同频道的玩家互不可见，且不会互相同步消息。分线在程序方面主要用于减少网络包，在策划层面会有一些其他的应用。分线是基于场景的，我们的可见性，以及消息同步默认以场景为单位。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"五、细节与其他 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码管理 大型项目中会遇到一种代码管理模式，基于分层的思想。底层代码会在一个代码库中，项目上层代码会在一个代码库，项目工具代码会在一个代码库。三个代码分别检出构成最终的项目。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"检测与转换 配置检测主要是检测表与表之间的关联性，检测是否存在重复id行，检测值的范围是否正确。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"异常处理 我们需要先划分最小的异常范围，然后在进行少量的异常捕获，在捕获后需要把异常的对象清理掉。这就是整个异常处理的过程。这里需要掌握的是核心的处理方式，就是我们怎么样可安全的处理好一个不确定性能的代码。 try{ //干第一件事 nIndex = 1; //干第二件事 nIndex = 2; //干第三件事 nIndex = 3; }catch{ swtich(nIndex){ case 0: break; case 1: break; case 2: break; } } ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"六、商业环境问题 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"程序负责人的关注 微观： 配置的定义 存储的数据结构定义 通信协议的定义 服务器，客户端模块通用部分的抽离客户端界面公共部分抽离 细节难点的处理 宏观： 内存的稳定 CPU的稳定 网络包量的稳定 程序本身的稳定 兼容性问题 综合： 资源的规划 设计的决策 代码规范的确立 后台（php）交互方式制定 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"报警机制 我们来看看什么情况需要报警。服务器短时间内多次重启需要报警，这种属于比较大的清晰可见的情况。往内一点讨论，当玩家存储的数据存储失败的时候，不一定需要报警。而当多个玩家出现这个情况时，就需要报警了。逻辑本身可能是会发生错误的，但是这种错误可小可大，我们不需要每个错误都去报警，这样会干扰我们正常的开发。我们尝试再加入触发次数这样的条件来定义一个报警事件。当多个玩家在一段时间内发生了多次值得报警的bug的时候，比如存储数据失败，登录失败，充值失败，在游戏中无法移动等情况，我们都可以进行报警。报警采用的游戏处理手段可以是停止新玩家登录，也可以是关服等。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"游戏更新 服务端的更新与客户端的更新如何同时生效，使用版本管理 需要同时生效是因为服务端和客户端都可能更新配置，而配置我们希望是两端读到的都是一样的。服务端的更新我们可以做到瞬间就能生效，但是客户端的代码资源都是放在CDN上，更新生效的时间是不一定的。那么我们可以看到的是同时生效的难题在于客户端资源的生效时间是不确定的。我们需要引入资源的版本机制，就像前面说的缓存更新一样。我们在CDN生效之后，再更新服务端，继而切换资源的版本号，通过这样来达到它们的同时生效。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity"],"content":"捏脸主要是通过复制一份骨骼（称为编辑骨骼）的Transform值，带动蒙皮来实现体型的变化，主要技术点在实现方式，编辑器开发，骨骼数据的组织方式，数据的存取。","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"总览 捏脸主要是通过复制一份骨骼（称为编辑骨骼）的Transform值，带动蒙皮来实现体型的变化，主要技术点在实现方式，编辑器开发，骨骼数据的组织方式，数据的存取。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:1:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"主要的类和方法 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"CommonCustomizeDNA 自定义部位可以改变的值，包括Transform的各个分量，共9个，加一个整体缩放 public XXX { scaleX, rotaionX ... } ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:1","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"CommonCustomizeDNAConfig 自定义部位可以改变的值范围，包括Transform的各个分量，共9个，加一个整体缩放 public XXX { scaleXmin, scaleYmin, ... } ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:2","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"BodyCustomizeDNA 预定义的可调节部分，可能作用于单根骨骼，也可以一个参数作用于多个骨骼，也可以改变整体缩放（单独处理） 还包括了自定义的DNA属性 //在z轴方向缩放，改骨骼scale值 [LabelOverride(\"胸腔前后\",\"上身\")] [Range(160,60)] public upperBodyFB; //偏移 [LabelOverride(\"胸部左右\",\"上身\")] [Range(160,60)] public bustOffsetLR； ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:3","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"BodyCustomizableSlot 数据类，可编辑的最小单位，主要存数据，包括操作的细项属性，原骨骼，编辑的骨骼 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:4","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"BodyCustomizableController 定义每个槽位的信息，包括了名字，操作的骨骼名字，编辑模式（改变自身，改变自身和子对象，改变自身以及非BIP骨骼） 初始化做了 根据固定槽位列表，找到对应的bone 整合固定的槽位列表和自定义的槽位列表 根据上面的数据，按模式生成编辑骨骼，生成一份一模一样的骨骼（Transform信息也一致），放到原骨骼下面，如果编辑模式为修改自己以及子对象，则把原骨骼的子对象都放到编辑骨骼下面。生成一份新的骨骼放在原骨骼的子节点，编辑骨骼可以受到动画和自定义值的双重影响，其子节点能受到自定义值得影响。 把编辑骨骼替换原有骨骼整合到蒙皮中，mesh.bones，使其能够影响蒙皮 ApplyDna方法，主要把配置的值（BodyCustomizeDNA）赋值到可编辑骨骼中 根据BodyCustomizeDNA值对BodyCustomizableSlot的编辑骨骼进行三维度缩放（放大缩小效果） BodyCustomizeDNA的配置值直接对特定BodyCustomizableSlot的编辑骨骼进行旋转处理（偏移效果） 处理自定义槽位的编辑骨骼旋转缩放位置，以及镜像编辑骨骼的旋转缩放位置 LateUpdate中处理某些父子骨骼的位置关系（脖子和头），子骨骼跟着父编辑骨骼走，主要针对BIP骨骼会被anim控制，也希望能受到父编辑骨骼的影响。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:5","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"体型变化实现原理 分三种操作类型 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"1. 整体缩放 改根节点缩放 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:1","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"2. 骨骼节点的各方向缩放 直接调scale的分量 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:2","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"3. 骨骼节点偏移 左右：直接改旋转值的Y值 localRotation = Quertnion.Euler(0,左右偏移值,0) 上下 localPosition = Quertnion.Euler(0,0,0)*Vetor3.up*上下偏移值 //好像就是等于y值。。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:3","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"数据存取方式 JSON进行存储，打包时用prefab索引起来，读取时也用prefab，后续可以打成二进制，比较省 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:4:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"高维控制 实际上就是把多个BodyCustomizableSlot打包成一个集合，可以初始化值，后面再做一下统一的缩放。比如改胖瘦，会同时改动腰部，胸部，大腿手臂等节点。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:5:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"捏脸实现 底层逻辑和捏体型一致，不同点 可以指定部位镜像处理，比如，改了左眼会同时改变右眼 一个部位有多个维度可以调整，代码预先设置好可以调整的细项，比如，对眼睛可以进行旋转平移拉伸共九个维度，加一个整体的缩放 体型可以调整的范围比较粗略，脸部每个部位的细项大多可以调整 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:6:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"几个问题 问：怎么避免受到动画控制器影响 答：复制一个节点用于调整，加入蒙皮 问：复制节点后怎么保证能影响到子节点 答：把非bip节点放到编辑节点下，bip节点在lateupdate中跟随编辑父节点同步位置（好像只同步了位置，没有做旋转和缩放的处理） ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:7:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"主要用于剔除遮挡以及LOD","date":"2022-11-12","objectID":"/instantoc/","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"原理 剔除遮挡+Lod，可以组合使用 相机每帧主动发射射线击中物体，击中后显示，并且重置周期 物体在周期后，主动向相机发射射线，判断是否需要隐藏 相机后的物体。减少DC（CPU压力），减少GPU剔除消耗；被遮挡的物体减少GPU渲染 ","date":"2022-11-12","objectID":"/instantoc/:1:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"IOCCam 每帧根据算法生成的随机点，向视锥体内发射若干条射线，击中以后，显示 并根据距离通过LODGroup切换高低模 参数：每帧发射的射线 不足：射线过多 改进：减少射线，延长周期（物体不主动发起射线） ","date":"2022-11-12","objectID":"/instantoc/:1:1","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"IOClod 初始化，根据相机距离和包围盒，初始化一个合适的Lod 剔除方法：Render enable设置为false或者修改阴影投射（一定距离内保持阴影，防止穿帮） 原版方案：周期从击中点向相机发射射线，被其他阻挡，则剔除 不足：随机的击中点，可能在侧面，或者后面，会自己把自己剔除掉 改进：击中点取2s中最近的击中点，作为击中点 ","date":"2022-11-12","objectID":"/instantoc/:1:2","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"LOD 运行时根据机型信息，设置IOClod的lod距离 cullDis，过远的直接隐藏，方法和上面一致 减少GPU需要处理的顶点数 ","date":"2022-11-12","objectID":"/instantoc/:2:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"使用 生成场景时给需要剔除的组件添加IOClod组件 ","date":"2022-11-12","objectID":"/instantoc/:3:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"指标 点面数 峰值点面数 ","date":"2022-11-12","objectID":"/instantoc/:4:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"优点 剔除不需要渲染的物体 根据距离切换LOD模型，甚至剔除 ","date":"2022-11-12","objectID":"/instantoc/:5:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"参考 IOC介绍 ","date":"2022-11-12","objectID":"/instantoc/:6:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"}]