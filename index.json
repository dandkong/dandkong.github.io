[{"categories":["Unity"],"content":"前言 在UI上显示特效是一直是一个比较棘手的问题，一开始的方案是调整UI特效的渲染顺序，设置其sortingLayer和sortingOrder+offset，在每个单独的UI以后渲染。 这种方法能满足大部分的需求，但也有缺点。 如果需要在特效上再盖一层UI的话，由于特效并不属于Canvas的一部分，所以修改Hierarchy并不能改变其渲染顺序，特效会在渲染完Canvas的UI元素以后再进行渲染，所以需要把这个UI的层级通过添加Canvas继续往上抬。 再者无法被RectMask2D和Mask裁剪，除非改造Shader，并手动传入裁剪区域。 最好的方法就是让特效像UI一样，直接按Hierarchy 顺序渲染，并支持遮罩，就是这文章的主角UIParticle。 ","date":"2024-06-06","objectID":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/:1:0","tags":["Unity","特效","UI"],"title":"UI特效插件-UIParticle","uri":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/"},{"categories":["Unity"],"content":"原理 This package utilizes the new APIsMeshBake/MashTrailBake(introduced with Unity 2018.2) to render particles through CanvasRenderer. You can render, mask, and sort your ParticleSystems for UI without the necessity of an additional Camera, RenderTexture, or Canvas. 这是项目首页的原理，具体就是通过一个API让例子特效通过CanvasRender进行渲染，这样就和普通的UI没什么不同了。 ","date":"2024-06-06","objectID":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/:2:0","tags":["Unity","特效","UI"],"title":"UI特效插件-UIParticle","uri":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/"},{"categories":["Unity"],"content":"使用 按官方的教程，直接引入包，添加组件到特效上，直接拖到UI中即可。 ","date":"2024-06-06","objectID":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/:3:0","tags":["Unity","特效","UI"],"title":"UI特效插件-UIParticle","uri":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/"},{"categories":["Unity"],"content":"改造已有shader以支持遮罩 项目推荐我们使用UIShader，如UIDefault或者UIAdditive。 Mask通过模板测试实现遮罩，RectMask2D通过传入裁剪区域实现。 所以自定义的Shader只需要参考上面的UIShader使其拥有遮罩特效即可，注意RenderQueue设置为Transparent，下面贴一下关键Shader代码。 Shader \"Your/Custom/Shader\" { Properties { // ... // #### required for Mask #### _StencilComp (\"Stencil Comparison\", Float) = 8 _Stencil (\"Stencil ID\", Float) = 0 _StencilOp (\"Stencil Operation\", Float) = 0 _StencilWriteMask (\"Stencil Write Mask\", Float) = 255 _StencilReadMask (\"Stencil Read Mask\", Float) = 255 _ColorMask (\"Color Mask\", Float) = 15 [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (\"Use Alpha Clip\", Float) = 0 } SubShader { Tags { // ... } // #### required for Mask #### Stencil { Ref [_Stencil] Comp [_StencilComp] Pass [_StencilOp] ReadMask [_StencilReadMask] WriteMask [_StencilWriteMask] } ColorMask [_ColorMask] // ... Pass { // ... // #### required for RectMask2D #### #include \"UnityUI.cginc\" #pragma multi_compile __ UNITY_UI_CLIP_RECT float4 _ClipRect; // #### required for Mask #### #pragma multi_compile __ UNITY_UI_ALPHACLIP struct appdata_t { // ... }; struct v2f { // ... // #### required for RectMask2D #### float4 worldPosition : TEXCOORD1; }; v2f vert(appdata_t v) { v2f OUT; // ... // #### required for RectMask2D #### OUT.worldPosition = v.vertex; return OUT; } fixed4 frag(v2f IN) : SV_Target { // ... // #### required for RectMask2D #### #ifdef UNITY_UI_CLIP_RECT color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect); #endif // #### required for Mask #### #ifdef UNITY_UI_ALPHACLIP clip (color.a - 0.001); #endif return color; } ENDCG } } } ","date":"2024-06-06","objectID":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/:4:0","tags":["Unity","特效","UI"],"title":"UI特效插件-UIParticle","uri":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/"},{"categories":["Unity"],"content":"总结 至此已经可以像UI一样使用UI特效了，具体的性能分析，参考一下首页。 ","date":"2024-06-06","objectID":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/:5:0","tags":["Unity","特效","UI"],"title":"UI特效插件-UIParticle","uri":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/"},{"categories":["Unity"],"content":"参考 https://github.com/mob-sakai/ParticleEffectForUGUI Unity Mask 和RectMask2D原理和区别-CSDN博客 Unity的三级排序层级渲染Layer,sorting layer,order in layer_unity layer 和order-CSDN博客 UGUI：调整Unity中UI和特效的层级关系（特效穿透问题）_unity中特效显示在image背景上 其他ui元素覆盖在特效上 层级怎么处理-CSDN博客 ","date":"2024-06-06","objectID":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/:6:0","tags":["Unity","特效","UI"],"title":"UI特效插件-UIParticle","uri":"/ui%E7%89%B9%E6%95%88%E6%8F%92%E4%BB%B6-uiparticle/"},{"categories":["Unity","游戏框架"],"content":"前言 最近在写游戏demo的时候，在写初始化流程的时候遇到一些问题，一开始通过回调函数来控制初始化流程，并不直观，也不好分离逻辑。进入游戏以后首先是准备好必要的资源，通过YooAssets进行加载，加载完成以后再进行游戏系统的初始化。一开始是在资源加载接口加了回调，加载完以后再进行游戏初始化，但不够优雅，如果需要更多的流程控制会写得比较乱。 最后用状态机实现游戏初始化的流程，首先就是要写一个有限状态机了，参考了一下开源的项目，这里总结一下。 ","date":"2024-06-02","objectID":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/:1:0","tags":["Unity","游戏框架"],"title":"使用状态机初始化游戏","uri":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/"},{"categories":["Unity","游戏框架"],"content":"状态机 管理状态：启动，状态转换，管理状态的生命周期 数据处理能力：增删查数据，状态中可以使用这些全局数据 ","date":"2024-06-02","objectID":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/:2:0","tags":["Unity","游戏框架"],"title":"使用状态机初始化游戏","uri":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/"},{"categories":["Unity","游戏框架"],"content":"状态 状态定义具体的逻辑，有OnInit,OnEnter,OnUpdate,OnLeave,OnDestroy生命周期。状态内调用状态机进行状态的切换。 ","date":"2024-06-02","objectID":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/:3:0","tags":["Unity","游戏框架"],"title":"使用状态机初始化游戏","uri":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/"},{"categories":["Unity","游戏框架"],"content":"UML类图 ","date":"2024-06-02","objectID":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/:4:0","tags":["Unity","游戏框架"],"title":"使用状态机初始化游戏","uri":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/"},{"categories":["Unity","游戏框架"],"content":"参考 GitHub - EllanJiang/GameFramework: This is literally a game framework, based on Unity game engine. It encapsulates commonly used game modules during development, and, to a large degree, standardises the process, enhances the development speed and ensures the product quality. UniFramework/UniFramework at main · gmhevinci/UniFramework ","date":"2024-06-02","objectID":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/:5:0","tags":["Unity","游戏框架"],"title":"使用状态机初始化游戏","uri":"/%E4%BD%BF%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B8%B8%E6%88%8F/"},{"categories":["Unity","学习笔记"],"content":"前言 YooAsset是一套Unity的资源管理方案，类似Unity提供的Addressable资源系统配置好了资源规则，后面只需要用一个“寻址路径”就能透明加载资源，无需关注位于什么bundle包，以及bunlde的依赖关系，也无需关注资源包是位于本地或者远端CDN。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:1:0","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"接入流程 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:2:0","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"安装YooAsset 参照官网教程即可，这里使用package进行安装。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:2:1","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"资源配置 资源配置是YooAsset系统的亮点所在，这里用一个简单的登录界面作为例子配置一下。 首先看看文件目录，这里需要加载LoginView，LoginView里用到了test图片，test图片又被收集在图集login中。 资源配置有几个重要的概念，分别是AddressRule，CollecterType，PackRule，FilterRule ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:2:2","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"AddressRule 可寻址规则，这是加载资源时需要传入的字符串，通过这个地址找到资源所在的包，这里使用默认完整路径加载。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:2:3","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"CollecterType MainAssetCollector 收集参与打包的主资源对象，并写入到资源清单的资源列表里（可以通过代码加载）。 StaticAssetCollector 收集参与打包的主资源对象，但不写入到资源清单的资源列表里（无法通过代码加载）。 DependAssetCollector 收集参与打包的依赖资源对象，但不写入到资源清单的资源列表里（无法通过代码加载）（当依赖资源没有被任何主资源引用的时候，则会在打包的时候自动剔除）。 首先看UIPrefabs，需要直接用代码加载的，设置为MainAssetCollector 再看图集Atlas，login中的所有精灵图片都被收集在图集文件中，但是不需要单独被代码加载，设置为StaticAssetCollector。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:2:4","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"PackRule PackSeparately 以文件路径作为资源包名，每个资源文件单独打包。 PackDirectory 以文件所在的文件夹路径作为资源包名，该文件夹下所有文件打进一个资源包。PackTopDirectory 以收集器下顶级文件夹为资源包名，该文件夹下所有文件打进一个资源包。PackCollector 以收集器路径作为资源包名，收集的所有文件打进一个资源包。 PackGroup 以分组名称作为资源包名，收集的所有文件打进一个资源包。PackRawFile 目录下的资源文件会被处理为原生资源包。 首先看UIPrefabs，prefab的上层文件夹就是一个模块，所以希望同一个模块的prefab都打到一个资源包中，使用 PackTopDirectory。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:2:5","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"FilterRule CollectAll 收集目录下的所有资源文件 CollectScene 只收集目录下的场景文件 CollectPrefab 只收集目录下的预制体文件 CollectSprite 只收集目录下的精灵类型的文件 UIPrefabs设置为CollectPrefab ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:2:6","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"资源构建 资源构建，分别有版本号，构建模式（强制打包，增量打包…），加密类型，压缩类型，Bundle包的命名风格，以及内建资源选项。 点击打包后，会生成几种关键的文件 bundle后缀的就是资源文件，这里包含了指定打包的prefab文件，和一个依赖引用的图片bundle。 PackageManifest开头的是资源清单文件，只是格式不同，这里打开json后缀的查看一下。 可以看到记录了一些打包的信息。 第一部分是打包的基本信息。 第二部分是资源列表，加载的时候就是从资源列表去找到对应的Bundle，因为只有Prefab设置为MainAssetCollector，所以资源列表只有下面的LoginView.prefab。 可以看到这个资源处于Bundle0中，也就是下面的assets_content_ui_prefabs_login.bundle，又依赖了share_assets_content_ui_images_login.bundle即图片文件。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:3:0","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"初始化和加载 编辑器模拟模式 单机运行模式 联机运行模式 WebGL运行模式 这里使用单机运行模式，如果使用联机运行模式需要CDN和指定更多的初始化参数，具体参考官方教程。 void Start() { // 初始化资源系统 YooAssets.Initialize(); StartCoroutine(InitializeYooAsset()); } private IEnumerator InitializeYooAsset() { // 创建默认的资源包 var package = YooAssets.CreatePackage(\"DefaultPackage\"); // 设置该资源包为默认的资源包，可以使用YooAssets相关加载接口加载该资源包内容。 YooAssets.SetDefaultPackage(package); var initParameters = new OfflinePlayModeParameters(); yield return package.InitializeAsync(initParameters); var go = YooAssets.LoadAssetSync\u003cGameObject\u003e(\"Assets/Content/UI/Prefabs/Login/LoginView.prefab\").AssetObject; Instantiate(go); } 可以看到prefab被正确加载并实例化出来了。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:4:0","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"总结 可以看到YooAsset提供了一个开箱即用的Unity资源管理框架，只需要少量的配置的和代码就能接入，后续的开发基本不用再维护了，只需调用接口加载即可。 这是YooAsset框架的第一篇文章，后面的文章会剖析其源码，也是对自己学习的一个记录。 待续。。。 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:5:0","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity","学习笔记"],"content":"参考 Introduce | YooAsset 【Unity游戏开发】SpriteAtlas与AssetBundle最佳食用方案 - 马三小伙儿 - 博客园 ","date":"2024-05-21","objectID":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/:6:0","tags":["Unity","资源"],"title":"YooAsset学习笔记1：接入流程","uri":"/yooasset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B/"},{"categories":["Unity"],"content":"前言 游戏的UI制作一直是程序员的考验，如果是程序员来拼UI的话，会遇到和美术效果不一样，如果是美术拼的话，又需要成本，美术一般对Unity不是很熟悉。之前也用过FGUI，但是bug不少，实际上用起来还是UGUI更为顺手。最后项目试用了PSD2GUI这个思路，把美术出的PSD直接转换成UGUI。理想的情况下是不用美术培训太多就能输出界面，所以没有做过多的组件支持，只是导出一些最基础的元素，比如图片和文字，程序在这基础上再进行加工，但也能省去大部分的重复工作了，而且不容易出错。如果流程更加成熟，可以培训美术理解更多prefab相关知识，可以支持导出一些列表，复选框之类的元素，但这要考虑成本。 代码基本来自https://github.com/zs9024/quick_psd2ugui/tree/master，基本没有用他的命名方式，只用了基本的图片和文字导出，支持了位置，大小，文本，文本颜色，透明度等基础信息。在实际实用中美术会标注一些不常规的情况，比如描边，渐变，图片的叠色，旋转，这些信息其实在PSD都有的，但是在API中并不能获取到，最后才参考【CEP教程-8】Action Manager从好奇到劝退 - 中篇，直接读取了图层效果里的描边和图片叠色，因为是直接读取的，所以美术并没有学习成本，渐变的参数过于复杂，有点难支持，旋转的信息暂时没找到简单方法获取，但也省下了一点成本。 ","date":"2024-03-16","objectID":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/:1:0","tags":["Unity","编辑器","UI","UGUI"],"title":"利用ActionManger拓展psd2gui","uri":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/"},{"categories":["Unity"],"content":"代码 主要就是利用ActionManger获取更多的PSD图层信息，PS在操作时会把数据都存到一个的结构中，只要能拿到这个结构，就能查到其中记录的数据，之后通过debug查看变量，或者通过示例代码照猫画虎即可。 /** * 这里就是拓展内容 function exportLabel(obj,validFileName){ var desc = getLayerInfoByID(obj.id) var json = ADToJSON(desc) //这里就可以取到描边信息类似json.FrameX.solidFill.color，具体debug可以看到 } */ /** * 这个函数接受一个AD的对象，返回这个对象所有属性值的JSON结构 * @param desc [ActionDescriptor] * @constructor * @return JSON */ function ADToJson(desc) { var json = {}; for (var i=0; i\u003cdesc.count; i++) { var typeID = desc.getKey(i); var stringID = typeIDToStringID(typeID); var typeString = (desc.getType(typeID)).toString(); switch(typeString) { case \"DescValueType.BOOLEANTYPE\": json[stringID] = desc.getBoolean(typeID); break; case \"DescValueType.DOUBLETYPE\": json[stringID] = desc.getDouble(typeID); break; case \"DescValueType.INTEGERTYPE\": json[stringID] = desc.getInteger(typeID); break; case \"DescValueType.STRINGTYPE\": json[stringID] = desc.getString(typeID); break; case 'DescValueType.OBJECTTYPE': var objectValue = desc.getObjectValue(typeID); json[stringID] = ADToJson(objectValue); break; case 'DescValueType.CLASSTYPE': case 'DescValueType.LISTTYPE': case 'DescValueType.REFERENCETYPE': // 剩下这些留给你去补充完成，这里还有UNITDOULETYPE之类的，像描边的size就是这类型 break; default: alert(typeString); break; } } return json; } /** * 根据图层ID来获取图层信息 * @param layerID * @return {*} */ function getLayerInfoByID(layerID) { var ref1 = new ActionReference(); ref1.putIdentifier(stringIDToTypeID( \"Lyr \", layerID)); var layerDescriptor = executeActionGet(ref1); var json = ADToJson(layerDescriptor); return json; } /** * 根据图层的顺序，来获取图层信息 * @param index * @return {*} */ function getLayerInfoByIndex(index) { var ref1 = new ActionReference(); ref1.putIndex( stringIDToTypeID( \"itemIndex\" ), index); var layerDescriptor = executeActionGet(ref1); var json = ADToJson(layerDescriptor); return json; } /** * 根据图层的名称，来获取图层信息 * @param index * @return {*} */ function getLayerInfoByName(name) { var ref1 = new ActionReference(); ref1.putName( stringIDToTypeID( \"layer\" ), name ); var layerDescriptor = executeActionGet(ref1); var json = ADToJson(layerDescriptor); return json } function getCurrentDocumentInfo() { var ref1 = new ActionReference(); ref1.putEnumerated(charIDToTypeID('Dcmn'), charIDToTypeID('Ordn'), charIDToTypeID('Trgt')); var docDescriptor = executeActionGet(ref1); var json = ADToJson(docDescriptor); return json } ","date":"2024-03-16","objectID":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/:2:0","tags":["Unity","编辑器","UI","UGUI"],"title":"利用ActionManger拓展psd2gui","uri":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/"},{"categories":["Unity"],"content":"总结 代码基本就是那样了，难点在于怎么知道json中的变量是对应自己想要的值，可以自己修改值，看看变化，或者通过参考【CEP教程-8】Action Manager从好奇到劝退 - 上篇，装个插件，每一部的ps操作都会生成log，可以更快找到所需变量。 jsx可以用vscode进行开发，配合插件ExtendScript可以输出日志和断点 ","date":"2024-03-16","objectID":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/:3:0","tags":["Unity","编辑器","UI","UGUI"],"title":"利用ActionManger拓展psd2gui","uri":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/"},{"categories":["Unity"],"content":"参考 【CEP教程-8】Action Manager从好奇到劝退 - 上篇 【CEP教程-8】Action Manager从好奇到劝退 - 中篇 【CEP教程-9】Action Manager从好奇到劝退 - 下篇 Photoshop插件开发教程 - （4）开发工具选择和调试 ","date":"2024-03-16","objectID":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/:4:0","tags":["Unity","编辑器","UI","UGUI"],"title":"利用ActionManger拓展psd2gui","uri":"/%E5%88%A9%E7%94%A8actionmanger%E6%8B%93%E5%B1%95psd2gui/"},{"categories":["Unity","性能优化"],"content":"Unity开发性能优化总结","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"Unity开发性能优化总结 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:0:0","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"1. 前言 工作几年，大部分的时间还是在业务开发，但是业务开发中也是要注意性能，如果不注意性能，积少成多可能也会导致游戏性能的下降。下面总结下自己理解到的性能注意项。 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:1:0","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2. 编程和代码架构 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:0","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2.1 lua使用的性能注意 交互原理：取值、入栈、c#到lua的类型转换，还有内存分配和GC。 lua与C#交互，做好缓存，减少如gameobject.transform.position.x之类的操作，可以在C#封装成GameObejct.GetPosX() 在lua中引用c#的object，代价昂贵 lua和c#之间传参、返回时，尽可能不要传递Vector3/Quaternion等unity值类型，数组等 参见：Unity+Lua性能优化（Lua和C#交互篇）-腾讯游戏学堂 (tencent.com) lua自身使用，减少全局表的查找，减少全局变量 lua与C#交互原理：wlgys8/UnityLuaInteractDemo: Unity中c#与lua的交互原理和用例 (github.com) ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:1","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2.2 减少字符串的使用 字符串使用性能较差，主要是在传值或者操作时都会有临时变量的产生，引发GC。 代码中减少字符串的拼接，拆分等操作，在Update中尤其需要注意。 使用hash替代字符串传值，参考Unity组件Animator、Material、Shader实现，对于固定的string，用一个字典存下所有字符串，统一转成hash再调用。 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:2","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2.3 缓存 GameObjects 和组件 GameObject.Find、GameObject.GetComponent 和 Camera.main都会有较大的性能负担，尽量只在初始化时调用，缓存下来使用。 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:3","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2.4 对象池 对象池包括类和GameObject，使用对象池可减少了实例化和销毁带来的性能消耗，减少托管内存分配的次数、防止产生垃圾回收。 注意对象池的缓存上限，没有上限的话对内存会有负担。 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:4","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2.5 使用正确的数据结构 注意list，dict等的使用，查找数据的时候尽量减少遍历，可以使用字典查找，降低复杂度。 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:5","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2.6 减少每帧的代码量 Update每帧执行，不一定所有的代码调用都需要在里面调用。 对于需要定时执行的逻辑也不一定要每帧执行，如倒计时，可以每秒执行，定期执行。 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:6","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"2.7 其他 减少日志的打印，日志打印同样会有字符串的消耗，封装好的打印方法还会进行本地的写法，无用的日志就不要打印了。 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:2:7","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"3. UI优化手段 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:3:0","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"3.1 减少渲染的量级和少内存 避免过重UI，拆分成小UI，动态加载 需要响应Raycast事件时，不要使用空Image，可以自定义组件继承自MaskableGraphic，重写OnPopulateMesh把网格清空，这样可以响应Raycast而又不需要绘制Mesh ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:3:1","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"3.2 减少OverDraw 减少UI重叠 全屏UI隐藏后面的UI 关掉场景相机的渲染 慎用Mask组件（浅谈Unity uGUI Mask组件实现原理 (rugbbyli.gitlab.io),Unity中的Mask组件增加DrawCall的原因unity mask组件流浪打工人的博客-CSDN博客） 慎用Shadow与Outline组件，顶点过多（慎用Outline ,UGUI Outline实现原理分析__Captain的博客-CSDN博客） 简单的粒子特效 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:3:2","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"3.3 图集 不同的图集/材质会产生DrawCall，且会引起加载问题 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:3:3","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"3.4 其他 避免频繁调用SetActive方法，会导致网格重建，会导致内存分配，触发GC，可以设置layer或把渲染移到相机外 ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:3:4","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity","性能优化"],"content":"3.5 参考资料 UGUI性能优化总结 | 无境 (drflower.top) 浅谈UGUI的渲染机制 - cancantrbl - 博客园 (cnblogs.com) Unity 面试题汇总（五）性能优化知识点相关_unity cruncher_仙魁XAN的博客-CSDN博客 https://github.com/Lafree317/Unity-InterviewQuestion/blob/master/优化.md ","date":"2023-07-08","objectID":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/:3:5","tags":["Unity","性能优化"],"title":"Unity开发性能优化总结","uri":"/unity%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"},{"categories":["Unity"],"content":"根据Prefab自动生成Lua代码，添加按钮回调，添加组件引用，添加自定义代码。","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"1 前言 最近回到了新项目，发现UI框架还是旧的那一套，每个UI控件，比如Text、Button等，都要手动打代码Find一遍，每次开发都会做很多无用功，所以打算优化一下效率。 设想是做一套工具，可以自动把UI代码生成出来。需求如下 把UI层和逻辑层的代码分开，第一次导出时才导出逻辑层，后续只导出覆盖UI层。 能对自动Button，Toggle等组件加上回调，由逻辑层复写 能控制是否导出子节点 能对BaseView和UIComponent分开导出 变量命名检测，重名自动改名 不影响旧代码 自动添加UIComponent的引用 思路 增加一个C#配置类（UIExportConfig），挂载在prefab上，表示需要导出成哪种代码类型（视图/组件）。 配置每种控件需要怎么导出，是否需要校验名字（因为有些不需要获取，比如界面中的固定图片和文本是不需要导出的）。 递归导出带UIExportConfig的GameObject。 ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:1:0","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"2 UI结构 UI里面主要有两个概念，视图和组件，都由一个基类派生而来，在游戏中体现为一个单独的prefab。 ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:2:0","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"2.1 组件 组件UI逻辑的最小单位，比如背包中的背包页和仓库页就是两个组件，背包页和仓库页中的道具格子也是一个组件。 ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:2:1","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"2.2 视图 视图也是组件，表现为游戏中的一个独立界面，比如一个背包界面，一个玩法界面，由自身以及嵌套的组件实现其不同功能，实现解耦和复用的目的。 ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:2:2","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"3 实现 一个组件，对应一个prefab，会导出一个以“UI”为后缀的UI类，如下： ---BagViewUI.lua --基础节点 self.txtTitle = self:FindCom(\"Text\",\"textTitle\") self.img1 = self:FindCom(\"Image\",\"textTitle/img1\") --背包页子组件 self.bagCom = BagCom.New(self:Find(\"BagCom\") --仓库页子组件 self.storgeCom = StorgeCom.New(self:Find(\"StorgeCom\") UI类会被逻辑类引用，如下： ---BagView.lua self.ui = BagViewUI.New(self.gameObject) self.ui.txtTitle.text = \"背包\" self.bagCom:SetData(背包数据); self.storgeCom :SetData(仓库数据); ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:3:0","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"3.1 导出图片，按钮，文本等组件 脚本通过深度遍历的方式遍历prefab的每个节点，对于合适的节点，生成一句查找代码，类似： ---BagViewUI.lua --基础节点 self.txtTitle = self:FindCom(\"Text\",\"textTitle\") self.img1 = self:FindCom(\"Image\",\"textTitle/img1\") 但不是所有节点都是需要导出的，网上有些做法是在节点加上组件表示要导出，我的做法是通过前缀命名来标识，每个需要导出的类型都有类型和前缀的双重验证，如果一个Text组件命名为“label”，就不会被导出。 组件 前缀 Button btn Image img Text txt ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:3:1","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"3.2 导出嵌套组件 如果一个组件中包含了另一个组件，会导出对应的引用比如，背包中有背包分页和仓库分页，背包分页和仓库分页又会导出他们对应的UI文件，层层嵌套解耦。 ---BagViewUI.lua --基础节点 self.txtTitle = self:FindCom(\"Text\",\"textTitle\") self.img1 = self:FindCom(\"Image\",\"textTitle/img1\") --背包页子组件 self.bagCom = BagCom.New(self:Find(\"BagCom\") --仓库页子组件 self.storgeCom = StorgeCom.New(self:Find(\"StorgeCom\") ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:3:2","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"3.3 自动添加自定义内容 至此在写UI的时候应该不用手打Find了，但有一些重复的代码还可以进行针对性的优化，项目中主要做了，对按钮添加回调，在逻辑类中复写。这个都是可以拓展，对于不同的节点类型，生成不同的代码。 ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:3:3","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"3.4 还能做得更好 可以给UI代码加入生命周期，在关闭界面以后做一些组件的清理，因为自己手动在逻辑类中清理经常会漏掉。 能对变体做一定的处理，如一种组件的不同样式，有没有办法可以不用复制两份一样的逻辑代码，应该应该可以用上继承的思想。 ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:3:4","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"4 总结 这套方法已经用了一段时间了，确实能省下不少的重复工作，第一省去了手动Find的过程，第二是自动添加了组件的引用，让功能解耦，更好维护了。 项目中还配个了另一个工具，通过美术的PSD生成UI prefab，再对prefab进行一定调整，把需要用到的节点改下名，再导出UI类，就可以在逻辑类中使用了，让前端只需要关心逻辑实现，解放双手，后面研究一下里面的实现原理。 ","date":"2023-06-07","objectID":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/:4:0","tags":["Unity","编辑器","UI","UGUI"],"title":"根据Prefab自动生成Lua代码","uri":"/%E6%A0%B9%E6%8D%AEprefab%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90lua%E4%BB%A3%E7%A0%81/"},{"categories":["Unity"],"content":"简要概括帧同步，状态同步和状态帧同步的原理以及优缺点","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"1. 状态同步 服务端接受客户端的操作，计算逻辑，分发到各客户端，游戏世界玩家没有属性变化，基本不会进行同步消息下发。 ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:1:0","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"优点 服务端可靠 断线重连简单，把当前状态下发 ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:1:1","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"缺点 回放需要单独的服务器，保存所有的状态，按时间发 服务器压力大，计算多 开发复杂 ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:1:2","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"2. 帧同步 服务端只做转发操作，转发各个客户端，大多数帧同步的逻辑是只放在每个客户端的，无论是否有操作，每一帧都会有服务器数据下发。 ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:2:0","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"优点 回放简单，只要把操作都记录下来就好 开发简单 ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:2:1","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"缺点 不安全，客户端能篡改 断线重连需要把之前所有操作加速一遍 注意随机数每次都一样 ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:2:2","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"3. 状态帧同步 状态帧同步就是状态同步和帧同步的概念相结合。客户端向服务器上传操作，服务器跑逻辑，但是又在按照固定的每一帧下发所有玩家的状态（属性位置等）给每一个客户端实现同步。客户端做预测，服务端做校验，不正确就回滚数据。 ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:3:0","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["Unity"],"content":"4. 参考 https://zhuanlan.zhihu.com/p/36884005 https://www.cnblogs.com/October2018/p/16120681.html ","date":"2023-05-11","objectID":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/:4:0","tags":["Unity","网络"],"title":"状态同步与帧同步","uri":"/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5/"},{"categories":["编程语言"],"content":"Lua知识点总结","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"Lua知识点总结 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:0:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"1. 元表和元方法 __index元方法 \u003e other = { foo = 3 } \u003e t = setmetatable({}, { __index = other }) \u003e t.foo 3 \u003e t.bar nil mytable = setmetatable({key1 = \"value1\"}, { __index = function(mytable, key) if key == \"key2\" then return \"metatablevalue\" else return nil end end }) __nexindex方法 --没有的减赋值到元表中 mymetatable = {} mytable = setmetatable({key1 = \"value1\"}, { __newindex = mymetatable }) print(mytable.key1) mytable.newkey = \"新值2\" print(mytable.newkey,mymetatable.newkey) mytable.key1 = \"新值1\" print(mytable.key1,mymetatable.key1) mytable = setmetatable({key1 = \"value1\"}, { __newindex = function(mytable, key, value) rawset(mytable, key, \"\\\\\"\"..value..\"\\\\\"\") --如果这里写成mytable[key]=value，会递归了 end }) mytable.key1 = \"new value\" mytable.key2 = 4 print(mytable.key1,mytable.key2) rawget和rawset raw方法就是忽略table对应的metatable，绕过metatable的行为约束，强制对原始表进行一次原始的操作，也就是一次不考虑元表的简单更新。 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:1:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"2. lua面向对象实现 使用元表，__index父类，并在new方法返回一个新的table function class(classname, super) local superType = type(super) local cls -- inherited from Lua Object if super then cls = {} setmetatable(cls, {__index = super}) cls.super = super else cls = {ctor = function() end} end cls.__cname = classname cls.__ctype = 2 -- lua cls.__index = cls function cls.new(...) local instance = setmetatable({}, cls) instance.class = cls instance:ctor(...) return instance end return cls end ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:2:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"3. Table实现原理 数组和哈希的混合结构 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:3:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"4. 游戏常用方案 XLua ， ToLua ， ULua都只是提供了 C# 与 Lua 的互相调用机制，差别基本就是少量的语法差别。座位C#和lua的中间层，把C#生成Wrap代码，经过xlua调用Lua代码。 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"Lua调用C# Lua-C dll- C# Wrap-C# 通过ObjectTranslator获取C#中的实例 Wrap方式：非反射机制，需要为源文件生成相应的wrap文件，当启动Lua虚拟机时，Wrap文件将会被自动注册到Lua虚拟机中，之后，Lua文件将能够识别和调用C#源文件 总结：Lua调用Wrap文件， Wrap文件调用C#源文件 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:1","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"参考 【ToLua】C#和Lua的交互细节 【Unity游戏开发】tolua之wrap文件的原理与使用 - 马三小伙儿 - 博客园 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:4:2","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"5. LuaGC ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"原理 标记，清除 三色标记 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:1","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"参考 Lua GC机制分析与理解-上 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:5:2","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"6.弱表 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"概括 • weak表中的引用是弱引用(weakreference)，弱引用不会导致对象的引用计数变化。换言之，如果一个对象只有弱引用指向它，那么gc会自动回收该对象的内存。 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:1","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"示例 强表 strongTable = {} strongTable[1] = function() print(\"i am the first element\") end strongTable[2] = function() print(\"i am the second element\") end strongTable[3] = {10, 20, 30} print(table.getn(strongTable)) -- 3 collectgarbage() print(table.getn(strongTable)) -- 3 v模式 weakTable = {} weakTable[1] = function() print(\"i am the first element\") end weakTable[2] = function() print(\"i am the second element\") end weakTable[3] = {10, 20, 30} setmetatable(weakTable, {__mode = \"v\"}) -- 设置为弱表 print(table.getn(weakTable)) --\u003e3 ele = weakTable[1] -- 给第一个元素增加一个引用 collectgarbage() print(table.getn(weakTable)) --\u003e1，第一个函数引用为1，不能gc ele = nil -- 释放引用 collectgarbage() print(table.getn(weakTable)) --\u003e0，没有其他引用了，全部gc k模式 t = {}; -- 给t设置一个元表，增加__mode元方法，赋值为“k” setmetatable(t, {__mode = \"k\"}); -- 使用一个table作为t的key值 key1 = {name = \"key1\"}; t[key1] = 1; key1 = nil; -- 又使用一个table作为t的key值 key2 = {name = \"key2\"}; t[key2] = 1; key2 = nil; -- 强制进行一次垃圾收集 collectgarbage(); for key, value in pairs(t) do print(key.name .. \":\" .. value); end --输出 为空 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:2","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"应用 弱引用：当一个对象只被弱表引用时，如果该对象没有被其他对象引用，那么它会被垃圾回收。 缓存：当一个对象不被引用UI，可以从弱表被删除。 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:3","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"参考 [Lua]弱表Weak table_ouyangshima的博客-CSDN博客 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:6:4","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"7. 参考 Lua知识点整理 ","date":"2023-04-11","objectID":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/:7:0","tags":["Lua"],"title":"Lua知识点总结","uri":"/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"STL种类以及其底层实现","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"分类 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:0","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"Vector动态数组 原理：连续的内存，start,end,max，max代表容量，end代表当前最大 扩容流程：申请空间，复制，清理 访问方式 //方式一：单个访问，假设num数组中已经有了5个元素 cout \u003c\u003c num[4] \u003c\u003c \"\\\\n\"; //输出第五个数据 //一二维可变数组和普通数组的访问方法一样 //方式二:遍历 for(int i = 0; i \u003c num.size(); i++) cout \u003c\u003c num[i] \u003c\u003c \" \";//下标范围在[0,num.size()),前开后闭 //方式三：智能指针 for(auto i : num) cout \u003c\u003c i \u003c\u003c \" \"; ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:1","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"list 概述：较快增删查 原理：双向链表 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:2","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"stack栈 概述：先进后出 原理：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:3","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"queue队列 概述：先进先出 原理：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:4","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"deque双端队列 概述：首位都能操作 原理：deque 容器的分段存储结构，提高了在序列两端添加或删除元素的效率，但也使该容器迭代器的底层实现变得更复杂。 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:5","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"priority_queue优先队列 概述：优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。 原理：priority_queue的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:6","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"set和multiset集合 概述：set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许 原理：底层红黑树，平衡二叉树可以保证在最坏情况下仍然具有较高的搜索效率，时间复杂度为O(logn)。 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:7","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"map和multimap 原理：底层红黑树 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:8","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"hash_set和hash_multiset 原理：哈希 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:9","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"hashmap/unordered_map和hash_multimap 原理：哈希 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:1:10","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"注意 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:2:0","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"什么时候需要用hash_map，什么时候需要用map? 总体来说，hash_map 查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n) 小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且hash_map的构造速度较慢。 现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用。 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:2:1","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["编程语言"],"content":"参考 C++ STL deque容器底层实现原理（深度剖析） C++ STL中哈希表 hash_map从头到尾详细介绍_c++ 哈希表_susandebug的博客-CSDN博客 C++ STL 几个容器的底层实现 收藏一下_stl c++底层实现_孤鸿踏雪的博客-CSDN博客 红黑树（图解+秒懂+史上最全） - 疯狂创客圈 - 博客园 ","date":"2023-04-02","objectID":"/stl%E6%80%BB%E7%BB%93/:3:0","tags":["编程语言","C++","STL"],"title":"STL总结","uri":"/stl%E6%80%BB%E7%BB%93/"},{"categories":["Unity"],"content":"输入模块是游戏中的基础系统，需要封装中间层适配PC平台与移动平台，并提供常用接口。","date":"2022-12-13","objectID":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/","tags":["Unity","游戏框架"],"title":"游戏输入模块","uri":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"概述 输入模块是游戏中的基础功能，主要有以下功能 为多平台提供统一接口支持，如移动设备和PC 触发开始按下，按下，抬起事件 区分点击UI和点击场景中的物体，执行不一样的逻辑 支持多点触控 ","date":"2022-12-13","objectID":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/:1:0","tags":["Unity","游戏框架"],"title":"游戏输入模块","uri":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"多平台 PC上鼠标操作：Input.GetMouseButton(index) 移动设备：Input.GetTouch(index) ","date":"2022-12-13","objectID":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/:2:0","tags":["Unity","游戏框架"],"title":"游戏输入模块","uri":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"判断点击在UI上 主要用到EventSystem中的RaycastAll接口，参考https://blog.csdn.net/u013012420/article/details/106999229 public void RaycastAll(EventSystems.PointerEventData eventData, List\u003cRaycastResult\u003e raycastResults); ","date":"2022-12-13","objectID":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/:3:0","tags":["Unity","游戏框架"],"title":"游戏输入模块","uri":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"点击流程 ","date":"2022-12-13","objectID":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/:4:0","tags":["Unity","游戏框架"],"title":"游戏输入模块","uri":"/%E6%B8%B8%E6%88%8F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"一、概述 游戏中角色移动分为了主动和被动，主动主要由玩家通过摇杆或者键盘进行操作，被动移动主要应用于自动寻路，通过寻路点行动。 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:1:0","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"二、主动移动 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:0","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"移动组件 移动组件主要用到Unity的移动组件Character Controller，主要属性如下 Height角色的高度，通常和现实中的人物一样设置为2米左右。 Radius角色的半径，用于控制人物的胖瘦。 Center设置角色中心点的位置。 Slope Limit限制角色能爬的最大坡度。通常设置为90度以下，这样角色就不会走到墙上。 Step Offset移动步长。通常2米左右的人移动步长设置在0.1到0.4米. Skin Width皮肤厚度。如果这个值太小角色容易被卡住，太大角色容易抖动。通常将这个数据设为0.01到角色半径的10%之间。 Min Move Distance最小移动距离。官方推荐把这个值设为0。 isGrounded可以获取角色当前是否在地面。 velocity可以获取角色当前的速度向量。 移动方法主要用到Move，Move方法需要自己实现重力的效果，看具体项目需求 //用摇杆控制方向，当按下空格键时跳起。 using UnityEngine; using System.Collections; public class ExampleClass : MonoBehaviour { public float speed = 6.0F; public float jumpSpeed = 8.0F; public float gravity = 20.0F; private Vector3 moveDirection = Vector3.zero; void Update() { CharacterController controller = GetComponent\u003cCharacterController\u003e(); if (controller.isGrounded) { moveDirection = GetTargetPos(nowPos) - nowPos; // 跳跃 if (Input.GetButton(\"Jump\")) moveDirection.y = jumpSpeed; } //Move方法需要自己写重力效果 moveDirection.y -= gravity * Time.deltaTime; //移动控制器 controller.Move(moveDirection * Time.deltaTime); } } ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:1","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"每帧目标点的计算 速度模拟模拟现实中人物移动的特征，起步时加速，计算代码如下 Vector3 GetTargetPos(Vector3 pos) { //计算实时速度，addSpeed为加速度 curMoveSpeed = Mathf.MoveTowards(curMoveSpeed, MaxSpeed, addSpeed * deltaTime); //计算终点，curMoveDir由输入决定 pos += curMoveSpeed * curMoveDir * deltaTime } ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:2","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"动画状态机 移动时需要动作配合，动作主要由Animator组件实现，通过设置不同的参数，实现状态之间的转换，还可以细化，加上准备跳跃，跳跃落地等等。 通过SetTrigger进行不同运动状态的切换，通过SetBool进行移动和静止状态间的切换。 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:3","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"管理组件 主动移动的管理组件主要功能如下 接收输入方向 状态机维护当前角色状态（普通，跳跃），设置对应动画状态 计算下一帧移动方向 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:2:4","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"三、自动寻路 自动寻路主要是计算出起始点到目标点的一连串的中间点，每次走一小段直线，从而完成寻路的过程，逻辑比较简单， 如果使用Unity自带的Nav Mesh Agent 可以使用参考https://bbs.huaweicloud.com/blogs/303788。 ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:3:0","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"计算寻路点 计算寻路点主要用到Unity的NavMesh类中的CalculatePath方法，得到寻路点以后只要逐个进行寻路即可。 public static bool CalculatePath(Vector3 sourcePosition, Vector3 targetPosition, int areaMask, AI.NavMeshPath path); ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:3:1","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Unity"],"content":"逐点寻路 计算出寻路点以后，在Update中执行 private void UpdateMove(float deltaTime) { float time = Vector3.Distance(_nowPos, _destList[index])/speed; If(deltaTime \u003e time) { //如果到最后一个，结束 //没有的话，index++ //多出的时间留给下个寻路点 UpdateMove(deltaTime - time); } else { //插值 _nowPos = Vector3.Lerp(_nowPos, _destList[index], deltaTime / time); } } ","date":"2022-12-12","objectID":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/:3:2","tags":["Unity","寻路"],"title":"人物移动模块","uri":"/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%A8%A1%E5%9D%97/"},{"categories":["游戏框架"],"content":"概述 一般副本中都会包括各种各样的行为和判断逻辑，下面举一个简单的副本例子，进入副本后，如果组队人数到达三个，则刷出怪物，播放特效，播放对话，与怪物战斗后，弹出结算UI，再播个动画。 如果由策划出完案子后程序负责直接实现的话，每个副本都是定制化的，写起来非常难受，而且维护极不方便，一旦需求改动就要重新写代码 所以需要设计一套副本系统可以灵活配置副本功能，想法是把副本里的每个行为，判断都作为一个节点，类型行为树的概念，从开始节点一直执行到结束节点，这个副本进程就结束了，进入下个副本进程。 编辑器使用连线的方式操作，每个节点的前后置关系，导出lua配置供程序使用，服务端控制执行流程，客户端只需要执行节点逻辑。 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:1:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"例子 节点可以分为执行节点和判断节点，执行节点执行一个行为，流程推进，判断节点在符合条件的时候，推进流程，否则暂停。 端口定义了每个节点间的关系，也就是图中的连线，控制流程走向，比如刷怪战斗节点，输入端口连接“判断组队人数”，有两个输出端口，分别是胜利和失败，连接对应的节点。 把副本流程解构成一个个节点以后，只需要维护节点的行为和端口逻辑即可，组合由策划完成，只有在添加新节点时程序才需要上场。 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:2:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"编辑器 编辑器可以用网上的开源例子xnode组织节点，也可自己实现。 导出的数据包括了节点的类型，参数，前后置节点等一切代码需要的信息。 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:3:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"副本流程 服务端推送当前节点信息 服务端执行/客户端执行 服务端/客户端完成节点，推进流程 直到到达结束节点 ","date":"2022-12-09","objectID":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/:4:0","tags":["游戏框架","副本","编辑器"],"title":"副本逻辑框架","uri":"/%E5%89%AF%E6%9C%AC%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"一、概述 一般MMO的游戏由场景和场景中的对象构成，在设计地图时，就会遇到几个问题。怎么有效直观地配置信息，对象都有什么功能，有什么功能是共有的。针对上面的问题，首先需要解决的是抽象出场景对象结构，在此基础上做编辑器，用图形化的界面展示，修改储存数据，供代码使用。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:1:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"二、场景对象结构 场景本事有数据，如场景资源，组队人数限制等等，这种信息改动不大，也比较直观，一般只要存在excel里面就好，需要的话可以做图形编辑器对excel进行读写和修改。 场景中的对象可以按需分成几类，常见的有npc，采集物，区域，点等等。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"NPC NPC主要承载了显示模型的功能，读取NPC表。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:1","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"采集物 采集物和NPC差不多，只是对话交互改成了点击采集。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:2","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"区域 区域分成了圆形区域和多边形区域，划分区域可以实现进入和离开区域的逻辑，比如划分了游泳区，飞行区等，进入以后主角切换运动状态。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:3","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"点 点的功能比较广泛，主要用于定位，也可以添加触发组件以后实现圆形区域的功能。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:4","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"组件 组件是对象上的属性和功能，公用的组件有缩放，大小，显示隐藏条件等，特殊的组件有巡逻，交互按钮等，按需添加，从而赋予对象特性。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:2:5","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"三、场景编辑器 理清了场景对象的结构以后，就可以做编辑器把数据组织起来了，场景编辑器的实现细节不多说，尽量用起来符合直观操作即可，功能如下。 增删改场景信息 直观展示场景中的对象（位置、模型、范围等） 增删改场景中的对象 修改对象的组件属性 导出程序可用数据 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:3:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"四、数据载体 数据可以直接导出lua，也可以导出成json，xml等，只要方便维护，程序方便调用即可。 目前使用的是先储存到excel，再从excel导出到lua中，供程序调用。 使用excel作为中间载体的原因可能是比较直观，但感觉使用json或者Unity序列化的方法也是可行的。 ","date":"2022-12-05","objectID":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/:4:0","tags":["游戏框架","场景","编辑器"],"title":"场景数据框架","uri":"/%E5%9C%BA%E6%99%AF%E6%95%B0%E6%8D%AE%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"概述 游戏对象管理一般是通过总分结构，管理器为RoleMgr，对象为Role，Role的功能由各种功能组件实现，从而实现继承和解耦。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:1:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"RoleMgr 管理类管理游戏中所有的Role，负责Role的创建、查找、销毁，一般配合UID生成器，给每一个Role分配一个唯一ID作为唯一的标识。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:2:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"Role Role是游戏中的对象，可以是角色，特效，建筑等等游戏中的一切实体，由BaseRole派生。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:3:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"BaseRole 基类，定义Role的最基本信息，如GameObject，Transform信息，显示隐藏状态等等。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:4:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"派生 对BaseRole进行派生就是具体的游戏对象，如添加了控制器以后就是角色，再添加主动移动的控制器以后就是主角，通过绑定不同的组件实现Role的不同方向功能。 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:5:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"Role的功能 Role的功能都由挂载的组件实现，常用的组件有 模型组件 被动移动组件 主动移动组件 显示隐藏组件（多条件） 范围触发组件（当玩家走进时会触发回调） 头顶文本组件 还有各种项目中需要实现的功能 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:6:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["游戏框架"],"content":"Role的结构 ","date":"2022-11-27","objectID":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/:7:0","tags":["游戏框架","角色"],"title":"游戏对象框架","uri":"/%E6%B8%B8%E6%88%8F%E5%AF%B9%E8%B1%A1%E6%A1%86%E6%9E%B6/"},{"categories":["Unity"],"content":"前言 UI是游戏中很重要的一部分，工作大多是繁复的，所以有一套功能强大，操作简单直观的UI解决方案是非常有必要的。 上半年一直在用FGUI，和之前用的UGUI相比下来，各有优缺点，对比分析记录一下。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:1:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"一、介绍 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:2:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"UGUI UGUI是Unity原生提供的UI方案，提供了基本的UI组件，如图片，文本，按钮，复选框，进度条等等，正是因为UGUI是面向普遍开发，所以没有封装很多高级的组件，比如虚拟列表。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:2:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"FGUI FairyGUI（下来简称FGUI）号称易上手，直观，零代码，有一个独立的编辑器，封装了很多高级的UI组件，用起来不需要自己造轮子。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:2:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"二、编辑器使用体验 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:3:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"UGUI 优点：稳定。 缺点：因为集成在Unity中，资源管理不太方便，需要项目定好规范，编写工具提交效率。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:3:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"FGUI 优点：有单独的编辑器，所有资源统一管理，美术策划也能很快上手使用。 缺点：不稳定，经常会莫名卡住，导出的时候经常报错。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:3:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"三、基础组件 基础组件上面因为FGUI实现很多的高级功能，所以使用起来体验要么一样，要么好点。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"文本 FGUI文本支持ubb语法，富文本支持图文混排，超链接等等，自动大小的文本。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"列表 FGUI实现了虚拟列表，树列表。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"字体 字体上FGUI提供了工具制作美术字，只要把资源拖进去专用的编辑器就能很快做出一个美术字体。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:3","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"动效系统 两者都有动效系统，UGUI上叫Animation，功能上差不多，都很强大。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:4:4","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"四、对齐系统 对齐系统这一块，FGUI是很大的亮点。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:5:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"UGUI UGUI的锚点系统以中心点为基准，对父节点对齐，提供了上下左右，拉伸对齐方式。 **优点：**简单直观UI默认的中心点在中心，符合人的正常思维。 缺点：不够灵活；同级UI之前的关联对齐要依赖其他布局组件；缺乏针对同级元素的对齐工具，不过可以自己拓展实现，可以参考我的另一篇文章。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:5:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"FGUI 优点：FGUI的对齐系统叫做关联系统，第一个优点是不局限与与父节点对齐，可以对任意两个元素进行对齐。第二个优点是在拓展了对齐的维度，可以以上下左右边缘为基准，可以以上下左右为基准拉伸，复杂一点，但是学会以后可以很方便实现一些效果，比如一张图片随着文字的变长而往右移动。 缺点：垂直布局和水平布局功能太单一；锚点在左上角各种反人类。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:5:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"五、FGUI特色功能 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"资源引用查找工具 可以轻易找到组件（图片）和其他组件的引用关系。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:1","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"支持多国语言 原生支持多国语言，可以导出xml维护即可。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:2","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"控制器系统 控制器系统一般用于控制显示一些UI元素的状态，可以配合动效和Tab使用，UGUI一般要通过代码控制或者自己实现一个类似的系统。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:3","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"多平台 FGUI可以一套UI，应用到不同的游戏引擎去，比如Unity和Unreal，对于后期可能更换引擎的项目，节省掉很多成本。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:4","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"插入3D物体 支持在UI层中插入任何3D物体，例如模型、粒子、骨骼动画等，UGUI中要通过修改特效和UI的渲染顺序实现，比较麻烦。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:6:5","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"六、拓展性 两者都有拓展性，FGUI的拓展性在于代码是开源的，可以在底层定制适合项目的功能，但是编辑器是不开源的，所以编辑器里面的东西改不了，虽然编辑器提供了脚本拓展支持，但能实现的东西不多。 UGUI的拓展性在于可以轻松地对编辑器进行拓展，也可以加上各种效果，一般也不会动到底层的如网格重构和渲染的代码，真想修改的话可能要和Unity进行合作然后项目搞一个魔改版的Unity。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:7:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"七、总结 总的来说两种UI解决方案都可以商用，不会有特别大的问题。 要是策划美术拼UI的话，可以选择FGUI，相反要是程序负责的话，两者都可以，但个人感觉Unity上的操作更加熟悉一点，程序员也可以在平时的UI流程中，吸收一些FGUI的思想，做些工具提高UI的开发效率。 ","date":"2022-11-18","objectID":"/ugui%E5%AF%B9%E6%AF%94fgui/:8:0","tags":["Unity","UI","UGUI","FGUI"],"title":"UGUI对比FGUI","uri":"/ugui%E5%AF%B9%E6%AF%94fgui/"},{"categories":["Unity"],"content":"前言 上半年的大半年时间都在用FGUI，最近又用回了UGUI，发现FGUI的一些工具还是很高效的，比如对齐工具，想着说移植到UGUI里面去，上网搜了一圈还真有，原理并不复杂，就是进行一些数学计算出最终的位置。 不过也没有完全适合项目需求，针对原项目基础上添加了三个功能，下面介绍一下。 ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:1:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"一、撤销功能 原项目的工具在修改后，习惯性就按下Ctrl+Z，发现并不能撤销原来的操作，查询了Unity的API后，发现有个Undo的类，可以实现撤销功能，有很多方法，主要用到了RecordObject，代码如下 private static void SetTranPos(Transform tran, Vector3 pos) { Undo.RecordObject(tran, \"modify posstion\"); tran.position = pos; } ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:2:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"二、Selection.GameObjects不是按选择顺序的 API中的Selection.GameObjects用于获取当前选中的物件，数组的顺序和我选择的顺序无关，所以不能实现灵活的对齐，查询网上文章可以用Selection.Objects替代，里面的第一个元素就是Ctrl选中的第一个元素，以此类推，代码如下 //按选中顺序获取GameObjects private static GameObject[] GetOrderedSelctionObjs() { return Selection.objects.OfType\u003cGameObject\u003e().ToArray(); } ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:3:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"三、添加对父节点对齐 功能就是和标题一样，原项目是没有的，代码如下 //如果只选中一个，对父节点对齐 if (rects.Count == 1) { if (rects[0].parent != null \u0026\u0026 rects[0].parent.GetComponent\u003cRectTransform\u003e() != null) { rects.Insert(0, rects[0].parent.GetComponent\u003cRectTransform\u003e()); } } ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:4:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"四、代码 ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:5:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"UGUIAlign using System.Collections.Generic; using System.Linq; using UnityEditor; using UnityEngine; public enum AlignType { Top = 1, Left = 2, Right = 3, Bottom = 4, HorizontalCenter = 5, //水平居中 VerticalCenter = 6, //垂直居中 Horizontal = 7, //横向分布 Vertical = 8, //纵向分布 } public class UGUIAlign : Editor { [MenuItem(\"GameObject/UI/Align/Left 【左对齐】\")] static void AlignLeft() { Align(AlignType.Left); } [MenuItem(\"GameObject/UI/Align/HorizontalCenter 【水平居中】\")] static void AlignHorizontalCenter() { Align(AlignType.HorizontalCenter); } [MenuItem(\"GameObject/UI/Align/Right 【右对齐】\")] static void AlignRight() { Align(AlignType.Right); } [MenuItem(\"GameObject/UI/Align/Top 【顶端对齐】\")] static void AlignTop() { Align(AlignType.Top); } [MenuItem(\"GameObject/UI/Align/VerticalCenter 【垂直居中】\")] static void AlignVerticalCenter() { Align(AlignType.VerticalCenter); } [MenuItem(\"GameObject/UI/Align/Bottom 【底端对齐】\")] static void AlignBottom() { Align(AlignType.Bottom); } [MenuItem(\"GameObject/UI/Align/Horizontal 【横向分布】\")] static void AlignHorizontal() { Align(AlignType.Horizontal); } [MenuItem(\"GameObject/UI/Align/Vertical 【纵向分布】\")] static void AlignVertical() { Align(AlignType.Vertical); } public static void Align(AlignType type) { List\u003cRectTransform\u003e rects = new List\u003cRectTransform\u003e(); GameObject[] objects = GetOrderedSelctionObjs(); if (objects != null \u0026\u0026 objects.Length \u003e 0) { for (int i = 0; i \u003c objects.Length; i++) { RectTransform rect = objects[i].GetComponent\u003cRectTransform\u003e(); if (rect != null) rects.Add(rect); } } //如果只选中一个，对父节点对齐 if (rects.Count == 1) { if (rects[0].parent != null \u0026\u0026 rects[0].parent.GetComponent\u003cRectTransform\u003e() != null) { rects.Insert(0, rects[0].parent.GetComponent\u003cRectTransform\u003e()); } } if (rects.Count \u003e 1) { Align(type, rects); } } //按选中顺序获取GameObjects private static GameObject[] GetOrderedSelctionObjs() { return Selection.objects.OfType\u003cGameObject\u003e().ToArray(); } public static void Align(AlignType type, List\u003cRectTransform\u003e rects) { RectTransform tenplate = rects[0]; float w = tenplate.sizeDelta.x * tenplate.lossyScale.x; float h = tenplate.sizeDelta.y * tenplate.lossyScale.y; float x = tenplate.position.x - tenplate.pivot.x * w; float y = tenplate.position.y - tenplate.pivot.y * h; switch (type) { case AlignType.Top: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.lossyScale.y; Vector3 pos = trans.position; pos.y = y + h - th + trans.pivot.y * th; SetTranPos(trans, pos); } break; case AlignType.Left: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + tw * trans.pivot.x; SetTranPos(trans, pos); } break; case AlignType.Right: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + w - tw + tw * trans.pivot.x; SetTranPos(trans, pos); } break; case AlignType.Bottom: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.lossyScale.y; Vector3 pos = trans.position; pos.y = y + th * trans.pivot.y; SetTranPos(trans, pos); } break; case AlignType.HorizontalCenter: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float tw = trans.sizeDelta.x * trans.lossyScale.x; Vector3 pos = trans.position; pos.x = x + 0.5f * w - 0.5f * tw + tw * trans.pivot.x; SetTranPos(trans, pos); } break; case AlignType.VerticalCenter: for (int i = 1; i \u003c rects.Count; i++) { RectTransform trans = rects[i]; float th = trans.sizeDelta.y * trans.lossyScale.y; Vector3 pos = trans.position; pos.y = y + 0.5f * h - 0.5f * th + th * trans.pivot.y; SetTranPos(trans, pos); } break; case AlignType.Horizontal: float minX = GetMinX(rects); float maxX = GetMaxX(rects); rects.Sort(SortListRectTransformByX); float distance = (maxX - minX) / (rects.Count - 1); for (int i = 1; i \u003c rects.Count - 1; i++) { RectTransform trans = r","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:5:1","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"五、代码下载 https://github.com/dandkong/UGUIAlign ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:6:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity"],"content":"六、参考 Unity编辑器拓展之十：UI对齐工具 ","date":"2022-11-16","objectID":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/:7:0","tags":["Unity","编辑器","UI","UGUI"],"title":"UGUI对齐工具","uri":"/ugui%E5%AF%B9%E9%BD%90%E5%B7%A5%E5%85%B7/"},{"categories":["Unity","学习笔记"],"content":"前言 这本书忘记从哪里下载了，和别的技术书籍不太一样，大多的内容都比较贴合项目开发，所以有一定的参考价值。 里面有几个章节觉得有收获的，主要是框架的设计，以及一些解决问题的思路，大致做了笔记或者摘录。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"一、基础内容交流 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码规范 可读代码：由于动态语言的类型灵活性，可以在变量前加上变量类型简称 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"正确使用断言与返回 注意什么时候可以为空，不要盲目返回 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"可拓展接口使用 多参数，下面演示了三种写法，最终应该在保留必要参数的情况下，可选参数做成table addModulePower(nModuleId, nPower); addModulePower(nModuleId,nPower,bSyncMsg,bSendEvent, bOnlyBoss) if( tOption \u0026\u0026 tOption.bSyncMsg){ //做这个参数该干的事情 } ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"调试的思维与逻辑 正向和逆向思维，逆向更快 不易复现的bug，埋下日志，下次使用 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"培养敏锐的异常反应 注意生命周期的创建与销毁 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:5","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码修改与重构 我们在项目中秉持一个原则，如果有个接口让你不舒服，比如说多传了几个参数，那么我们一定要提出来，那一定是接口的设计不够简单或者没有提供更简单的接口形式。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:6","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"优雅的使用外部代码 我们的一个原则就是要尽可能少去直接和引擎进行交互，而是更多的进行局部缓存，把战场拉回到更加通用的逻辑里面。 修改后的代码为： let levelSlider = Core.createBitmapByName(\"slider_png\"); let nSliderX = 0; if(XXX){ nSliderX += 6; } if(XXX){ nSliderX += 8; } if(XXX){ nSliderX -= 2; } levelSlider.x -= nSliderX; 选择简单的接口/参数以及尽量少的使用/调用底层接口就是我们所谓的正确的代码使用方式。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:7","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码审查 取出一个管理器对象。然后直接访问了它的成员函数，这是非常不应该行为。第一个是这个成员不应该是公有的，而应该是私有的，它的公有性质破坏了类的封装。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:8","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"从面试的角度看面试 基础能力，逻辑能力，硬核能力 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:9","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"如何应对代码错误 作为项目的主程，还需要统一思想。这个过程包括要求大家遵循统一的代码命名等，这也是规避错误的一个重要手段。越是相似的代码风格，代码的阅读速度就会越快。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:10","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"二、逻辑设计模式式讨论 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"分层设计 事件的派发遵循从下往上：比如M驱动V 依赖性越强的越靠下层 变化的放上层，底层可以互相依赖，逻辑层不允许相互依赖 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"主动和被动 被动模式，依赖事件，及时，性能消耗少，当被动模式不在能支持复杂逻辑时，可以考虑主动模式 主动模式，依赖轮询，有点像ESC的系统层监听实体层的感觉了。优点在于可以监听多种条件 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"阻塞和非阻塞 主要用于资源加载，阻塞速度快 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"统一与非统一 效率没有打到一定程度的影响时，推荐考虑统一性 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"三、框架设计初步 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"基类 存活状态，唯一ID ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"框架代码结构 子类关注的基类接口一定是个空的实现，意味着子类不需要考虑去调用父类同名的接口。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"框架设计 配置化编程：消除重复代码，如协议监听，按钮监听等等 自动化平衡处理：如果没有销毁，帮忙擦下屁股 机制有助于实现全局性的功能，尤其处理大规模需要重复代码的东西 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"框架拓展的思路 基础能力，封装类，继承到框架中 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:4","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"四、逻辑设计原理 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"缓存的设计 缓存存放的东西有限，不能所有的东西都放缓存。 缓存应该具备清理功能。 缓存系统应该具备一定的匹配能力。 缓存具备最小保留数量以及预先创建的能力 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"分线漫谈 分线，是将玩家划分到不同的频道中，不同频道的玩家互不可见，且不会互相同步消息。分线在程序方面主要用于减少网络包，在策划层面会有一些其他的应用。分线是基于场景的，我们的可见性，以及消息同步默认以场景为单位。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"五、细节与其他 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"代码管理 大型项目中会遇到一种代码管理模式，基于分层的思想。底层代码会在一个代码库中，项目上层代码会在一个代码库，项目工具代码会在一个代码库。三个代码分别检出构成最终的项目。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"检测与转换 配置检测主要是检测表与表之间的关联性，检测是否存在重复id行，检测值的范围是否正确。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"异常处理 我们需要先划分最小的异常范围，然后在进行少量的异常捕获，在捕获后需要把异常的对象清理掉。这就是整个异常处理的过程。这里需要掌握的是核心的处理方式，就是我们怎么样可安全的处理好一个不确定性能的代码。 try{ //干第一件事 nIndex = 1; //干第二件事 nIndex = 2; //干第三件事 nIndex = 3; }catch{ swtich(nIndex){ case 0: break; case 1: break; case 2: break; } } ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"六、商业环境问题 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"程序负责人的关注 微观： 配置的定义 存储的数据结构定义 通信协议的定义 服务器，客户端模块通用部分的抽离客户端界面公共部分抽离 细节难点的处理 宏观： 内存的稳定 CPU的稳定 网络包量的稳定 程序本身的稳定 兼容性问题 综合： 资源的规划 设计的决策 代码规范的确立 后台（php）交互方式制定 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"报警机制 我们来看看什么情况需要报警。服务器短时间内多次重启需要报警，这种属于比较大的清晰可见的情况。往内一点讨论，当玩家存储的数据存储失败的时候，不一定需要报警。而当多个玩家出现这个情况时，就需要报警了。逻辑本身可能是会发生错误的，但是这种错误可小可大，我们不需要每个错误都去报警，这样会干扰我们正常的开发。我们尝试再加入触发次数这样的条件来定义一个报警事件。当多个玩家在一段时间内发生了多次值得报警的bug的时候，比如存储数据失败，登录失败，充值失败，在游戏中无法移动等情况，我们都可以进行报警。报警采用的游戏处理手段可以是停止新玩家登录，也可以是关服等。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity","学习笔记"],"content":"游戏更新 服务端的更新与客户端的更新如何同时生效，使用版本管理 需要同时生效是因为服务端和客户端都可能更新配置，而配置我们希望是两端读到的都是一样的。服务端的更新我们可以做到瞬间就能生效，但是客户端的代码资源都是放在CDN上，更新生效的时间是不一定的。那么我们可以看到的是同时生效的难题在于客户端资源的生效时间是不确定的。我们需要引入资源的版本机制，就像前面说的缓存更新一样。我们在CDN生效之后，再更新服务端，继而切换资源的版本号，通过这样来达到它们的同时生效。 ","date":"2022-11-12","objectID":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","tags":["Unity","游戏框架"],"title":"《游戏逻辑思想》学习笔记","uri":"/%E6%B8%B8%E6%88%8F%E9%80%BB%E8%BE%91%E6%80%9D%E6%83%B3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Unity"],"content":"捏脸主要是通过复制一份骨骼（称为编辑骨骼）的Transform值，带动蒙皮来实现体型的变化，主要技术点在实现方式，编辑器开发，骨骼数据的组织方式，数据的存取。","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"总览 捏脸主要是通过复制一份骨骼（称为编辑骨骼）的Transform值，带动蒙皮来实现体型的变化，主要技术点在实现方式，编辑器开发，骨骼数据的组织方式，数据的存取。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:1:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"主要的类和方法 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"CommonCustomizeDNA 自定义部位可以改变的值，包括Transform的各个分量，共9个，加一个整体缩放 public XXX { scaleX, rotaionX ... } ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:1","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"CommonCustomizeDNAConfig 自定义部位可以改变的值范围，包括Transform的各个分量，共9个，加一个整体缩放 public XXX { scaleXmin, scaleYmin, ... } ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:2","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"BodyCustomizeDNA 预定义的可调节部分，可能作用于单根骨骼，也可以一个参数作用于多个骨骼，也可以改变整体缩放（单独处理） 还包括了自定义的DNA属性 //在z轴方向缩放，改骨骼scale值 [LabelOverride(\"胸腔前后\",\"上身\")] [Range(160,60)] public upperBodyFB; //偏移 [LabelOverride(\"胸部左右\",\"上身\")] [Range(160,60)] public bustOffsetLR； ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:3","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"BodyCustomizableSlot 数据类，可编辑的最小单位，主要存数据，包括操作的细项属性，原骨骼，编辑的骨骼 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:4","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"BodyCustomizableController 定义每个槽位的信息，包括了名字，操作的骨骼名字，编辑模式（改变自身，改变自身和子对象，改变自身以及非BIP骨骼） 初始化做了 根据固定槽位列表，找到对应的bone 整合固定的槽位列表和自定义的槽位列表 根据上面的数据，按模式生成编辑骨骼，生成一份一模一样的骨骼（Transform信息也一致），放到原骨骼下面，如果编辑模式为修改自己以及子对象，则把原骨骼的子对象都放到编辑骨骼下面。生成一份新的骨骼放在原骨骼的子节点，编辑骨骼可以受到动画和自定义值的双重影响，其子节点能受到自定义值得影响。 把编辑骨骼替换原有骨骼整合到蒙皮中，mesh.bones，使其能够影响蒙皮 ApplyDna方法，主要把配置的值（BodyCustomizeDNA）赋值到可编辑骨骼中 根据BodyCustomizeDNA值对BodyCustomizableSlot的编辑骨骼进行三维度缩放（放大缩小效果） BodyCustomizeDNA的配置值直接对特定BodyCustomizableSlot的编辑骨骼进行旋转处理（偏移效果） 处理自定义槽位的编辑骨骼旋转缩放位置，以及镜像编辑骨骼的旋转缩放位置 LateUpdate中处理某些父子骨骼的位置关系（脖子和头），子骨骼跟着父编辑骨骼走，主要针对BIP骨骼会被anim控制，也希望能受到父编辑骨骼的影响。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:2:5","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"体型变化实现原理 分三种操作类型 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"1. 整体缩放 改根节点缩放 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:1","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"2. 骨骼节点的各方向缩放 直接调scale的分量 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:2","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"3. 骨骼节点偏移 左右：直接改旋转值的Y值 localRotation = Quertnion.Euler(0,左右偏移值,0) 上下 localPosition = Quertnion.Euler(0,0,0)*Vetor3.up*上下偏移值 //好像就是等于y值。。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:3:3","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"数据存取方式 JSON进行存储，打包时用prefab索引起来，读取时也用prefab，后续可以打成二进制，比较省 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:4:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"高维控制 实际上就是把多个BodyCustomizableSlot打包成一个集合，可以初始化值，后面再做一下统一的缩放。比如改胖瘦，会同时改动腰部，胸部，大腿手臂等节点。 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:5:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"捏脸实现 底层逻辑和捏体型一致，不同点 可以指定部位镜像处理，比如，改了左眼会同时改变右眼 一个部位有多个维度可以调整，代码预先设置好可以调整的细项，比如，对眼睛可以进行旋转平移拉伸共九个维度，加一个整体的缩放 体型可以调整的范围比较粗略，脸部每个部位的细项大多可以调整 ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:6:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"几个问题 问：怎么避免受到动画控制器影响 答：复制一个节点用于调整，加入蒙皮 问：复制节点后怎么保证能影响到子节点 答：把非bip节点放到编辑节点下，bip节点在lateupdate中跟随编辑父节点同步位置（好像只同步了位置，没有做旋转和缩放的处理） ","date":"2022-11-12","objectID":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/:7:0","tags":["Unity","模型"],"title":"捏体型方案","uri":"/%E6%8D%8F%E4%BD%93%E5%9E%8B%E6%96%B9%E6%A1%88/"},{"categories":["Unity"],"content":"主要用于剔除遮挡以及LOD","date":"2022-11-12","objectID":"/instantoc/","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"原理 剔除遮挡+Lod，可以组合使用 相机每帧主动发射射线击中物体，击中后显示，并且重置周期 物体在周期后，主动向相机发射射线，判断是否需要隐藏 相机后的物体。减少DC（CPU压力），减少GPU剔除消耗；被遮挡的物体减少GPU渲染 ","date":"2022-11-12","objectID":"/instantoc/:1:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"IOCCam 每帧根据算法生成的随机点，向视锥体内发射若干条射线，击中以后，显示 并根据距离通过LODGroup切换高低模 参数：每帧发射的射线 不足：射线过多 改进：减少射线，延长周期（物体不主动发起射线） ","date":"2022-11-12","objectID":"/instantoc/:1:1","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"IOClod 初始化，根据相机距离和包围盒，初始化一个合适的Lod 剔除方法：Render enable设置为false或者修改阴影投射（一定距离内保持阴影，防止穿帮） 原版方案：周期从击中点向相机发射射线，被其他阻挡，则剔除 不足：随机的击中点，可能在侧面，或者后面，会自己把自己剔除掉 改进：击中点取2s中最近的击中点，作为击中点 ","date":"2022-11-12","objectID":"/instantoc/:1:2","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"LOD 运行时根据机型信息，设置IOClod的lod距离 cullDis，过远的直接隐藏，方法和上面一致 减少GPU需要处理的顶点数 ","date":"2022-11-12","objectID":"/instantoc/:2:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"使用 生成场景时给需要剔除的组件添加IOClod组件 ","date":"2022-11-12","objectID":"/instantoc/:3:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"指标 点面数 峰值点面数 ","date":"2022-11-12","objectID":"/instantoc/:4:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"优点 剔除不需要渲染的物体 根据距离切换LOD模型，甚至剔除 ","date":"2022-11-12","objectID":"/instantoc/:5:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"},{"categories":["Unity"],"content":"参考 IOC介绍 ","date":"2022-11-12","objectID":"/instantoc/:6:0","tags":["Unity","LOD","场景","剔除遮挡"],"title":"InstantOC + LOD","uri":"/instantoc/"}]