<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>编程语言 - 分类 - Dand&#39;s Blog</title>
        <link>https://dandkong.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link>
        <description>编程语言 - 分类 - Dand&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 17 Jul 2024 22:07:01 &#43;0800</lastBuildDate><atom:link href="https://dandkong.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="self" type="application/rss+xml" /><item>
    <title>PuerTS学习路线</title>
    <link>https://dandkong.github.io/puerts%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</link>
    <pubDate>Wed, 17 Jul 2024 22:07:01 &#43;0800</pubDate>
    <author>Dand</author>
    <guid>https://dandkong.github.io/puerts%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</guid>
    <description><![CDATA[前言 最近看到腾讯又出了个游戏脚本的热更方案，相对lua有以下的优势。
JavaScript生态有众多的库和工具链，结合专业商业引擎的渲染能力，快速打造游戏
相比游戏领域常用的lua脚本，TypeScript的静态类型检查有助于编写更健壮，可维护性更好的程序
安装 安装PuerTS | PUER Typescript
安装包到Unity，在合适的地方接入JSEnv
自定义加载器 PuerTS自带一个加载器，通过Resource加载JS代码，但是实际开发的时候推荐的是TypeScript，需要转译到JS再执行。
编辑器中推荐使用TS-Loader，编辑器中直接使用TS进行开发，没有其他需要关注的地方。
提供一个PuerTS的Loader，使你在Editor下，可以直接读取TS。
无需研究tsconfig、无需研究ESM、CommonJS，无需自行编译ts，无需理会和调试相关的debugpath/sourceMap/控制台跳转。
https://github.com/zombieyang/puerts-ts-loader
编辑器中直接使用TS开发，在发布时还需要编译成JS，参考ts-loader中的TSReleaser-Resources.cs函数，在发布资源前编译成JS。
编译好的JS要支持热更，所以使用默认的加载器，自己定义一个加载器，传入的参数是JS的路径，返回的是JS的代码内容，结合项目的资源加载返回即可，我的Demo使用了YooAssets框架。
调试 用类似NodeJs的方式调试即可。
VSCode Debug 指引 | PUER Typescript
TS学习 TS拥有静态类型检测，能编写更具有健壮性的代码，也有更多现有的资源。
深入理解 TypeScript | 深入理解 TypeScript
Handbook - The TypeScript Handbook
TypeScript 入门教程
ES6 入门教程
前言 | TypeScript手册]]></description>
</item>
<item>
    <title>Lua知识点总结</title>
    <link>https://dandkong.github.io/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
    <pubDate>Tue, 11 Apr 2023 21:40:59 &#43;0800</pubDate>
    <author>Dand</author>
    <guid>https://dandkong.github.io/lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[Lua知识点总结 1. 元表和元方法 __index元方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 &gt; other = { foo = 3 } &gt; t = setmetatable({}, { __index = other }) &gt; t.foo 3 &gt; t.bar nil mytable = setmetatable({key1 = &#34;value1&#34;}, { __index = function(mytable, key) if key == &#34;key2&#34; then return &#34;metatablevalue&#34; else return nil end end }) __nexindex方法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 --没有的减赋值到元表中 mymetatable = {} mytable = setmetatable({key1 = &#34;value1&#34;}, { __newindex = mymetatable }) print(mytable.]]></description>
</item>
<item>
    <title>STL总结</title>
    <link>https://dandkong.github.io/stl%E6%80%BB%E7%BB%93/</link>
    <pubDate>Sun, 02 Apr 2023 23:41:05 &#43;0800</pubDate>
    <author>Dand</author>
    <guid>https://dandkong.github.io/stl%E6%80%BB%E7%BB%93/</guid>
    <description><![CDATA[分类 Vector动态数组 原理：连续的内存，start,end,max，max代表容量，end代表当前最大
扩容流程：申请空间，复制，清理
访问方式
1 2 3 4 5 6 7 8 9 10 11 //方式一：单个访问，假设num数组中已经有了5个元素 cout &lt;&lt; num[4] &lt;&lt; &#34;\\n&#34;; //输出第五个数据 //一二维可变数组和普通数组的访问方法一样 //方式二:遍历 for(int i = 0; i &lt; num.size(); i++) cout &lt;&lt; num[i] &lt;&lt; &#34; &#34;;//下标范围在[0,num.size()),前开后闭 //方式三：智能指针 for(auto i : num) cout &lt;&lt; i &lt;&lt; &#34; &#34;; list 概述：较快增删查
原理：双向链表
stack栈 概述：先进后出
原理：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
queue队列 概述：先进先出
原理：底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
deque双端队列 概述：首位都能操作
原理：deque 容器的分段存储结构，提高了在序列两端添加或删除元素的效率，但也使该容器迭代器的底层实现变得更复杂。
priority_queue优先队列 概述：优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。
原理：priority_queue的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器
set和multiset集合 概述：set和multiset会根据特定的排序准则，自动将元素进行排序。不同的是后者允许元素重复而前者不允许
原理：底层红黑树，平衡二叉树可以保证在最坏情况下仍然具有较高的搜索效率，时间复杂度为O(logn)。
map和multimap 原理：底层红黑树]]></description>
</item>
</channel>
</rss>
